<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>百晓生的兵器谱</title>
  
  <subtitle>BAIXS&#39;s BOOK</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zyqvizzz.github.io/"/>
  <updated>2018-09-05T05:46:04.871Z</updated>
  <id>http://zyqvizzz.github.io/</id>
  
  <author>
    <name>断桥百晓生</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>毕业论文</title>
    <link href="http://zyqvizzz.github.io/%E6%98%9F%E4%BA%91%E9%93%BE/"/>
    <id>http://zyqvizzz.github.io/星云链/</id>
    <published>2018-09-05T05:18:09.000Z</published>
    <updated>2018-09-05T05:46:04.871Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于区块链的菜谱发布网站的设计和实现（Nebulas星云链）"><a href="#基于区块链的菜谱发布网站的设计和实现（Nebulas星云链）" class="headerlink" title="基于区块链的菜谱发布网站的设计和实现（Nebulas星云链）"></a>基于区块链的菜谱发布网站的设计和实现（Nebulas星云链）</h1><h2 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1. 绪论"></a>1. 绪论</h2><h3 id="1-1-研究目的"><a href="#1-1-研究目的" class="headerlink" title="1.1 研究目的"></a>1.1 研究目的</h3><p>区块链源自于比特币，而比特币被认为是一种去中心化，非普遍全球可支付的电子加密货币。从本质上讲，区块链技术，是一种交易记录的存储技术，它对交易记录进行永久性存储，而且存储之后永远无法删除，只能按照次序加入新的交易，由此对所有的交易历史进行永不结束的记载。这个看似简单的功能描述，实则含义深刻。它促使我们重新思考如何去创建交易、存储数据和交换资产，更重要的是，它将有机会彻底重塑当今社会的信任机制和价值体系。</p><p>技术的革新瞬息万变，区块链技术在历经8年的考验后终于站在了风口之上，2017年底，各种令人眼花缭乱的区块链项目，如同雨后春笋一般走进了我们的视野，其涉及到的应用场景种类繁杂，包括游戏，金融，支付，存储，物联网等等。但是由于区块链扩容难，速率慢且易拥堵，以及共识算法不完善等难题尚未被完全攻克，至今仍未有一个真正可以大规模落地的区块链应用出现。</p><p>我们站在时代的前沿，自然不能够故步自封，尽管这项技术至今还处在起步阶段，但我们仍然有足够的理由和热情去拥抱这项颠覆性的技术，所以在几个公链项目里如eos、eth、zilliqa和nas中进行了学习和甄选之后，我选择了由前蚂蚁金服区块链团队出品的星云链作为这次研究的对象。</p><h3 id="1-2-发展历程"><a href="#1-2-发展历程" class="headerlink" title="1.2 发展历程"></a>1.2 发展历程</h3><p>星云链（NAS）团队在2017年组成，并于2018年3月29日发布主网，是一套基于以太坊构建一个能够量化价值尺度、具备自进化能力，并能促进区块链生态建设的区块链系统，号称为”区块链中的搜索引擎”和”下一个谷歌”。</p><p>星云链的共识算法为POD（proof-of-devotion），即贡献度证明算法。贡献度证明算法本质上是对于在星云链上创造价值（比如 DApp ）的开发者进行奖励。如果你开发了一个 DApp 并且在星云链的网络上表现良好，你可以选择成为一个验证者（比如：验证一笔提交的交易），然后，作为回报，你会收到星云链发给你的代币奖励。该算法理论上可以实现一套可行的共识体系，但是“哲人王”式的共识体系使大部分代币持有者失去记账权，把信任建立在了技术水平上的做法并不能解除中心化的风险，它依然存在较大的争议。</p><p>星云链上其他内容有星云指数和星云原力。星云指数(Nebulas Rank)用于构建价值尺度：星云指数通过对星云链上产生的行为进行挖掘分析，将每个实体的重要程度进行量化。将区块链的维度提升到了三维，用它来衡量区块链世界的价值尺度，这样就可以对区块链里的应用进行分级评价，让优秀的应用浮现出来。而星云原力(Nebulas Force)则是自进化的区块链技术：目前的区块链项目的核心协议基本都是不支持升级的，包括智能合约，一经部署，就无法再升级。其中潜在的危害无疑是巨大的。对于这个问题，星云链提出了星云原力，一个区块链自进化的机智，用来对核心协议，智能合约进行升级和修复。在星云链中，代币持有者可以通过投票来达到升级智能合约的目的，如果大多数投票通过，那么 bug 就可以随时被修复。</p><p>星云链以DApp为核心概念，较之于同样以DApp为核心的航母级项目eos.io，它特有星云指数和星云原力对于普通开发者要更加友好。尽管和目前的每个公链项目一样，它自身仍然有众多瑕疵和不确定性，但对于入门DApp开发、理解智能合约来说，它是当仁不让的首选。</p><h3 id="1-3-开发工具的选择"><a href="#1-3-开发工具的选择" class="headerlink" title="1.3 开发工具的选择"></a>1.3 开发工具的选择</h3><h4 id="1-3-1-IDE选择"><a href="#1-3-1-IDE选择" class="headerlink" title="1.3.1 IDE选择"></a>1.3.1 IDE选择</h4><p>由于星云链为开发者提供了一套简单的JS-SDK，智能合约可以完全由JS编写，所以我选择了WebStorm作为本项目的开发工具。</p><h4 id="1-3-2-操作系统选择"><a href="#1-3-2-操作系统选择" class="headerlink" title="1.3.2 操作系统选择"></a>1.3.2 操作系统选择</h4><p>MacOS high Sierra。运行星云网络需要在Golang环境下运行，MacOS配置复杂的环境要比Windows更加简单，避免不必要的错误和麻烦。</p><h4 id="1-3-3-Web容器选择"><a href="#1-3-3-Web容器选择" class="headerlink" title="1.3.3 Web容器选择"></a>1.3.3 Web容器选择</h4><p>基于区块链的DApp项目不需要服务端支持，智能合约将取代服务端所具备的功能，部署在星云链主网。</p><h4 id="1-3-4-数据库"><a href="#1-3-4-数据库" class="headerlink" title="1.3.4 数据库"></a>1.3.4 数据库</h4><p>本地数据存储在Chrome浏览器提供的Web SQL 数据库中，远程数据存储在区块链中。</p><h4 id="1-3-5-编程框架"><a href="#1-3-5-编程框架" class="headerlink" title="1.3.5 编程框架"></a>1.3.5 编程框架</h4><p>前端使用JQuery开发，智能合约使用原生Javascript编写。前端及智能合约皆遵循ECMAScript5的标准编写。</p><h2 id="2-系统分析"><a href="#2-系统分析" class="headerlink" title="2. 系统分析"></a>2. 系统分析</h2><h3 id="2-1-主要功能"><a href="#2-1-主要功能" class="headerlink" title="2.1 主要功能"></a>2.1 主要功能</h3><ol><li>查看最热菜谱，该菜谱列表由点赞最多的菜谱组成；</li><li>查看所有菜谱，在这里可以按需找到任何想要的菜谱；</li><li>点击菜谱图片，可以查看菜谱的具体做法和步骤；</li><li>通过搜索功能，快速找到自己想要的菜谱；</li><li>按步骤录入并分享自己的菜谱；</li><li>点赞或打赏，打赏星云币，使用该功能必须下载浏览器钱包插件。</li></ol><h3 id="2-2-方案论证"><a href="#2-2-方案论证" class="headerlink" title="2.2 方案论证"></a>2.2 方案论证</h3><ol><li>网站界面：美食网站首先要考虑到的是食欲，所以界面将以干净和温暖的色调为主，通过简洁的界面，让用户感受到舒适的气氛。</li><li>功能实现：由于目前关于DApp开发的资料及其稀少，星云网络也处于非常早期的阶段，所以本项目将实现一些最基本的功能：单个菜谱的新增、修改、查看，过滤获取数据资源，以及最主要的星云币打赏交易。</li></ol><h3 id="2-3-基本思路"><a href="#2-3-基本思路" class="headerlink" title="2.3 基本思路"></a>2.3 基本思路</h3><h4 id="2-3-1-网站UI的思路"><a href="#2-3-1-网站UI的思路" class="headerlink" title="2.3.1 网站UI的思路"></a>2.3.1 网站UI的思路</h4><p>UI，对于设计者来说，可以算是最简单的地方；但对于用户一个良好的用户界面非常重要，普通用户根本不会关心你的界面时怎么实现的，他所关心的是UI是否美丽、大方、好看。如果一个网站的UI不好看，可能用户根本没有用下去的心思了。本网站使用Bootstrap作为UI框架，简单优美。</p><h4 id="2-3-2-获取数据的思路"><a href="#2-3-2-获取数据的思路" class="headerlink" title="2.3.2 获取数据的思路"></a>2.3.2 获取数据的思路</h4><p>所有数据均来自于Nebulas星云链，制定合适的抓取策略，获得所需要的资源。</p><h4 id="2-3-3-权限控制思路"><a href="#2-3-3-权限控制思路" class="headerlink" title="2.3.3 权限控制思路"></a>2.3.3 权限控制思路</h4><p>本应用的角色不存在多重权限，因为应用定位为菜谱分享网站，而不可篡改、不可回滚和可溯源则是区块链建立的初衷。所以它不需要一个特定的管理员去进行中心化的操作，那如何防止用户上传垃圾信息呢？解决方法是提高用户的上传成本，用户每上传一条信息，都需要向星云网络支付一定数额的星云币，这就在一定程度上保证了垃圾信息不会泛滥。但是当真正出现垃圾信息需要被清理的需求时，我们在星云网络上则有另一套更新策略，目前这一套dapp更新策略在整个区块链行业中尚不拥有一个真正完美的解决方案，所以在此不予讨论。把星云链钱包插件绑定在应用上，则钱包地址将成为标识身份的唯一ID，用户可以在发布菜谱的时候填写个人信息，如昵称等，它们不会跟着真正的数据一起上链，但是钱包地址将作为一个钩子获取到它们。</p><h3 id="2-4-主要问题"><a href="#2-4-主要问题" class="headerlink" title="2.4 主要问题"></a>2.4 主要问题</h3><p>该应用最主要的问题是更新和迭代，这也是目前所有dapp面临的问题，每次更新就意味着要把智能合约替换，而替换智能合约，就相当于弃用了旧的服务器，所有数据将从零开始。</p><h3 id="2-5-网站要求"><a href="#2-5-网站要求" class="headerlink" title="2.5  网站要求"></a>2.5  网站要求</h3><p>适配绝大部分IE9以上浏览器和移动端浏览器，有较快的响应速度，并且有合理的错误提示和404页面。</p><h2 id="附录：中英文翻译"><a href="#附录：中英文翻译" class="headerlink" title="附录：中英文翻译"></a>附录：中英文翻译</h2><p><strong>英文部分</strong></p><h3 id="A-Guide-to-99-Fault-Tolerant-Consensus（excerpt）"><a href="#A-Guide-to-99-Fault-Tolerant-Consensus（excerpt）" class="headerlink" title="A Guide to 99% Fault Tolerant Consensus（excerpt）"></a>A Guide to 99% Fault Tolerant Consensus（excerpt）</h3><p>We’ve heard for a long time that it’s possible to achieve consensus with 50% fault tolerance in a synchronous network where messages broadcasted by any honest node are guaranteed to be received by all other honest nodes within some known time period (if an attacker has more than 50%, they can perform a “51% attack”, and there’s an analogue of this for any algorithm of this type). We’ve also heard for a long time that if you want to relax the synchrony assumption, and have an algorithm that’s “safe under asynchrony”, the maximum achievable fault tolerance drops to 33% (PBFT, Casper FFG, etc all fall into this category). But did you know that if you add even more assumptions (specifically, you require observers, ie. users that are not actively participating in the consensus but care about its output, to also be actively watching the consensus, and not just downloading its output after the fact), you can increase fault tolerance all the way to 99%?</p><p>This has in fact been known for a long time; Leslie Lamport’s famous 1982 paper “The Byzantine Generals Problem” (link here) contains a description of the algorithm. The following will be my attempt to describe and reformulate the algorithm in a simplified form.</p><p>Suppose that there are N consensus-participating nodes, and everyone agrees who these nodes are ahead of time (depending on context, they could have been selected by a trusted party or, if stronger decentralization is desired, by some proof of work or proof of stake scheme). We label these nodes 0….N-1. Suppose also that there is a known bound D on network latency plus clock disparity (eg. D = 8 seconds). Each node has the ability to publish a value at time T (a malicious node can of course propose values earlier or later than T). All nodes wait (N-1) * D seconds, running the following process. Define x : i as “the value x signed by node i”, x : i : j as “the value x signed by i, and that value and signature together signed by j”, etc. The proposals published in the first stage will be of the form v: i for some v and i, containing the signature of the node that proposed it.</p><p>If a validator i receives some message v : i[1] : … : i[k], where i[1] … i[k] is a list of indices that have (sequentially) signed the message already (just v by itself would count as k=0, and v:i as k=1), then the validator checks that (i) the time is less than T + k * D, and (ii) they have not yet seen a valid message containing v; if both checks pass, they publish v : i[1] : … : i[k] : i.</p><p>At time T + (N-1) * D, nodes stop listening. At this point, there is a guarantee that honest nodes have all “validly seen” the same set of values.</p><p><img src="https://vitalik.ca/files/Lamport.png" alt=""></p><p><em>Node 1 (red) is malicious, and nodes 0 and 2 (grey) are honest. At the start, the two honest nodes make their proposals y and x, and the attacker proposes both w and z late. w reaches node 0 on time but not node 2, and z reaches neither node on time. At time T + D, nodes 0 and 2 rebroadcast all values they’ve seen that they have not yet broadcasted, but add their signatures on (x and w for node 0, y for node 2). Both honest nodes saw {x, y, w}.</em></p><p>If the problem demands choosing one value, they can use some “choice” function to pick a single value out of the values they have seen (eg. they take the one with the lowest hash). The nodes can then agree on this value.</p><p>Now, let’s explore why this works. What we need to prove is that if one honest node has seen a particular value (validly), then every other honest node has also seen that value (and if we prove this, then we know that all honest nodes have seen the same set of values, and so if all honest nodes are running the same choice function, they will choose the same value). Suppose that any honest node receives a message v : i[1] : … : i[k] that they perceive to be valid (ie. it arrives before time T + k * D). Suppose x is the index of a single other honest node. Either x is part of {i[1] … i[k]} or it is not.</p><ul><li>In the first case (say x = i[j] for this message), we know that the honest node x had already broadcasted that message, and they did so in response to a message with j-1 signatures that they received before time T + (j-1) <em> D, so they broadcast their message at that time, and so the message must have been received by all honest nodes before time T + j </em> D.</li><li>In the second case, since the honest node sees the message before time T + k <em> D, then they will broadcast the message with their signature and guarantee that everyone, including x, will see it before time T + (k+1) </em> D.</li></ul><p>Notice that the algorithm uses the act of adding one’s own signature as a kind of “bump” on the timeout of a message, and it’s this ability that guarantees that if one honest node saw a message on time, they can ensure that everyone else sees the message on time as well, as the definition of “on time” increments by more than network latency with every added signature.</p><p>In the case where one node is honest, can we guarantee that passive observers (ie. non-consensus-participating nodes that care about knowing the outcome) can also see the outcome, even if we require them to be watching the process the whole time? With the scheme as written, there’s a problem. Suppose that a commander and some subset of k (malicious) validators produce a message v : i[1] : …. : i[k], and broadcast it directly to some “victims” just before time T + k <em> D. The victims see the message as being “on time”, but when they rebroadcast it, it only reaches all honest consensus-participating nodes after T + k </em> D, and so all honest consensus-participating nodes reject it.</p><p><img src="http://vitalik.ca/files/Lamport2.png" alt=""></p><p>But we can plug this hole. We require D to be a bound on two times network latency plus clock disparity. We then put a different timeout on observers: an observer accepts v : i[1] : …. : i[k] before time T + (k - 0.5) <em> D. Now, suppose an observer sees a message an accepts it. They will be able to broadcast it to an honest node before time T + k </em> D, and the honest node will issue the message with their signature attached, which will reach all other observers before time T + (k + 0.5) * D, the timeout for messages with k+1 signatures.</p><p><img src="http://vitalik.ca/files/Lamport3.png" alt=""></p><p><strong>中文部分</strong></p><h3 id="99-容错共识算法（节选）"><a href="#99-容错共识算法（节选）" class="headerlink" title="99%容错共识算法（节选）"></a>99%容错共识算法（节选）</h3><p>作者：维塔利克·布特林</p><p>很长时间以来，我们都听说过在同步网络中有可能实现50%容错共识，其中通过任何诚实节点广播的消息保证能够在某个已知时段内被所有其他诚实节点收到（如果攻击者拥有超过50%的节点，他们能够实施“51%攻击”，对于任何此类的算法来说，都有类似的情况）。</p><p>我们也一直听说，如果您希望放宽同步假设，并有个“在异步下安全”的算法，那么最大可实现的容错率下降到33%（PBFT，Casper FFG等都属于这一类）。但是，如果增加更多的假设（具体来说，需要观察者也积极地观察共识，并且不只是事后才下载它的输出），就能够将容错率一直提高到99%。</p><p>事实上，这早已为人所知，Leslie Lamport写于1982年的著名论文《拜占庭将军问题》描述了该算法。下面是我尝试用简化的形式描述和重构该算法。</p><p>假设有N个节点，我们分别用0，……，N-1来标识，并且在网络延迟加上时钟差异有个已知的界限D（比如，D = 8 秒）。每个节点具有在时间T（恶意节点当然能够早于或晚于时间T）发布一个值的能力。所有节点等待(N - 1) * D秒，运行以下过程。定义 x : i是“节点i签署的值x”，x : i : j 是“节点i签署的值x，并且由节点j签署该值和签名”，等等。在第一个阶段发布的提议以v : i的形式出现，代表某些v和i，包含提出它的节点的签名。</p><p>如果验证节点i收到一些消息 v : i[1] : … : i[k]，其中 i[k]是一个索引列表，这些索引已经（顺序）签署了消息（只是v本身将计为 k = 0，并且 v:i计为 k = 1），然后，验证器检查（i）时间是否小于 T + K * D，以及（ii）它们是否还没看到一个有效的包含v的消息。如果这两个验证都通过，那么，它们就发布 v : i[1] : … : i[k] : i。</p><p>在 T + (N-1) * D时刻，节点停止侦听，它们使用一些“选择”功能从所有它们已经看到的有效消息中选择一个值（比如，它们取最高的）。然后，它们决定这个值。</p><p><img src="http://vitalik.ca/files/Lamport.png" alt=""></p><p><em>节点1（红色）是恶意节点，而节点0和节点2（灰色）是诚实节点。一开始，这两个诚实节点给出它们的提议 y 和 x，攻击者晚提出w和 z，w准时到达节点0，但是没能准时到达节点2，z既没有准时到达节点0，也没有准时到达节点2。在 T + D时刻，节点0和节点2重新广播了它们看到但还没有广播过的所有值，并在上面添加了它们的签名（x和 w用于节点0，y用于节点2）。两个诚实节点都看到了{x，y，w}，然后，它们可以使用一些标准选择函数（即，按字母顺序，最高的：y）。</em></p><p>现在，我们来探究一下这个为什么可行。我们需要证明的是，如果一个诚实节点已经看到一个特定值（有效的），然后，其他各个诚实节点也看到了该值（如果我们能证明这个，那么我们就知道所有的诚实节点在运行同样的选择函数，因此它们会输出相同的值）。假设任意一个诚实节点收到消息v : i[1] : … : i[k]，它们认为有效（即，它在 T + k * D时刻前到达）。 假设x是单个其他诚实节点的索引。那么，x要么是{i[1] … i[k]}的一部分，要么不是。</p><ul><li>在第一种情况下（设 x = i[j] 是这个消息），我们知道，诚实节点 x 已经广播了该消息，并且它们这么做是为了响应用在 T+ (j - 1)<em>D时刻前收到的带有j – 1个签名的消息，于是，它们在那个时刻广播了它们的消息，因此，在T+ j </em> D时刻前，所有诚实节点应该收到了该消息。</li><li>在第二种情况下，由于诚实节点在T + k <em> D时刻前看到了该消息，然后，它们将广播带着它们签名的数据，并保证包括x在内的每个节点都会在 T + (k+1) </em> D时刻前看到该消息。</li></ul><p>注意，该算法使用添加自己签名的操作，作为一种在超时消息上的“撞击”，并且这种能力保证，如果一个诚实节点看到准时的消息，它们可以确保其他任何节点也能准时看到该消息，因为“准时”的定义随着每个增加的签名而增加更多的网络延时。</p><p>在这种情况下，如果一个节点是诚实的，我们能否保证被动观察者也能够看到输出，就算我们要求它们一直观察过程？按照所写的计划，存在一个问题。假设命令者和一些k（恶意）验证器子集产生了一个消息 v : i[1] : … : i[k]，并且在 T + k <em> D时刻前，直接把它广播给了一些“受害者”。这些受害者认为该消息是准时的，但是，当它们重新广播该消息时，它只在 T + k </em> D时刻后到达所有诚实参与共识的节点，因此，所有诚实参与共识的节点都会拒绝该消息。</p><p><img src="https://res.infoq.com/articles/vitalik-buterin-proposes-consensus-algorithm/zh/resources/6272-1535217006997.png" alt=""></p><p>但是，我们可以补上这个漏洞。我们要求D受两倍网络时延加上时钟差异的约束。然后，我们对观察者施加不同的超时：观察者在 T + (k – 0.5) <em> D时刻前收到 v : i[1] : … : i[k]。现在，假设观察者看到一个消息并接收它。它们将能够在 T + k </em> D时刻前广播给一个诚实节点，并且诚实节点会发出附有其签名的消息，该消息将在 T + (k + 0.5) * D时刻前达到所有其他观察者，那么，具有 k+1个签名的消息超时。</p><p><img src="https://res.infoq.com/articles/vitalik-buterin-proposes-consensus-algorithm/zh/resources/5173-1535217007241.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基于区块链的菜谱发布网站的设计和实现（Nebulas星云链）&quot;&gt;&lt;a href=&quot;#基于区块链的菜谱发布网站的设计和实现（Nebulas星云链）&quot; class=&quot;headerlink&quot; title=&quot;基于区块链的菜谱发布网站的设计和实现（Nebulas星云链）&quot;&gt;
      
    
    </summary>
    
      <category term="区块链" scheme="http://zyqvizzz.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="毕业论文" scheme="http://zyqvizzz.github.io/tags/%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>用Callbacks Promises 和 Async/Await写一段异步代码</title>
    <link href="http://zyqvizzz.github.io/asynchronous/"/>
    <id>http://zyqvizzz.github.io/asynchronous/</id>
    <published>2018-08-12T07:31:09.000Z</published>
    <updated>2018-08-14T12:57:58.998Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>假设一个函数，每隔一段随机时间后打印一个字符串</p></blockquote><figure class="highlight plain"><figcaption><span>6</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function printString(string)&#123;</span><br><span class="line">    setTimeout(</span><br><span class="line">      ()=&gt;&#123;</span><br><span class="line">        console.log(string)</span><br><span class="line">      &#125;,</span><br><span class="line">      Math.floor(Math.random() * 100) + 1</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">//  现在，我们尝试着按顺序打印a b c</span><br><span class="line"></span><br><span class="line">function printAll()&#123;</span><br><span class="line">    printString(&quot;A&quot;);</span><br><span class="line">    printString(&quot;B&quot;);</span><br><span class="line">    printString(&quot;C&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printAll();</span><br></pre></td></tr></table></figure><p>每次调用printAll时，你会注意到A B C以不同的随机顺序打印。这是因为这些函数是异步的，每个函数按顺序执行，但每个函数都独立于它自己的setTimeout。在开始之前，他们不会等待最后一个功能完成。</p><a id="more"></a><p>现在，我们用callback回调修复它。</p><h2 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h2><figure class="highlight plain"><figcaption><span>6</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function printString(string, callback)&#123;</span><br><span class="line">  setTimeout(</span><br><span class="line">    ()=&gt;&#123;</span><br><span class="line">      console.log(string);</span><br><span class="line">      callback()</span><br><span class="line">    &#125;,</span><br><span class="line">    Math.floor(Math.random() * 100)+1</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">//  再次打印ABC</span><br><span class="line">function printAll()&#123;</span><br><span class="line">  printString(&quot;A&quot;, ()=&gt;&#123;</span><br><span class="line">    printString(&quot;B&quot;, ()=&gt;&#123;</span><br><span class="line">      printString(&quot;C&quot;, ()=&gt;&#123;&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">printAll();</span><br></pre></td></tr></table></figure><p>代码虽然很丑陋，但是行之有效。现在，它们会按照预期打印了。</p><p>回调是一个传递给另一个函数的函数，第一个函数完成，它将运行第二个函数。而回调的问题是它创建了一个名为回调地狱的东西。你将在函数内的函数嵌套函数，代码变得非常难以阅读。</p><p>接下来，试试用Promise解决这个嵌套问题。</p><h2 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h2><figure class="highlight plain"><figcaption><span>6</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  function printString(string)&#123;</span><br><span class="line">    return new Promise((resolve, reject)=&gt;&#123;</span><br><span class="line">      setTimeout(</span><br><span class="line">        ()=&gt;&#123;</span><br><span class="line">          console.log(string);</span><br><span class="line">          resolve();</span><br><span class="line">        &#125;,</span><br><span class="line">        Math.floor(Math.random()*100)+1</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">//  在这一步它们依然是相似的，整个函数包装在Promise中，而是调用resolve。</span><br><span class="line">//  该函数返回此Promise对象。</span><br><span class="line"></span><br><span class="line">  function printAll()&#123;</span><br><span class="line">    printString(&quot;A&quot;)</span><br><span class="line">      .then(()=&gt;&#123;</span><br><span class="line">        return printString(&quot;B&quot;);</span><br><span class="line">      &#125;)</span><br><span class="line">      .then(()=&gt;&#123;</span><br><span class="line">        return printString(&quot;C&quot;);</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  printAll();</span><br></pre></td></tr></table></figure><p>这叫Promise链，可以看到代码返回函数的结果（Promise），并将其发送到下一个函数。此时代码不需嵌套，但仍然很凌乱。</p><p>最后，还有一招。await。</p><p>await基本上是Promises的语法糖，它将使你的异步代码看起来更像是同步、过程代码更容易理解。</p><figure class="highlight plain"><figcaption><span>6</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//  printString无需更改</span><br><span class="line"></span><br><span class="line">async function printAll()&#123;</span><br><span class="line">    await printString(&quot;A&quot;);</span><br><span class="line">    await printString(&quot;B&quot;);</span><br><span class="line">    await printString(&quot;C&quot;);</span><br><span class="line">&#125;</span><br><span class="line">printAll()</span><br></pre></td></tr></table></figure><p>现在看起来非常舒服了。</p><p>包装函数printAll使用”async”关键字，这让我们的JavaScript知道我们正在使用async/await语法，如果你想使用await，async是个必要条件。这同时也意味着你不能从全局环境内使用await，它总是需要一个包装函数。</p><p>但是，现在的printString函数不返回任何内容，每个都是独立的，如果你想获取第一个函数的输出，在第二个函数中用它做一些事，然后将它传给第三个函数。这时应该怎么办呢？</p><p>让我们回到callback，再来一遍。</p><h2 id="callback-1"><a href="#callback-1" class="headerlink" title="callback"></a>callback</h2><figure class="highlight plain"><figcaption><span>6</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function addString(previous, current, callback)&#123;</span><br><span class="line">   setTimeout(</span><br><span class="line">     ()=&gt;&#123;</span><br><span class="line">       callback(previous + &apos; &apos; + current)</span><br><span class="line">     &#125;,</span><br><span class="line">     Math.floor(Math.random() * 100) + 1</span><br><span class="line">   )</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> function addAll()&#123;</span><br><span class="line">   addString(&apos;&apos;, &apos;A&apos;, result =&gt; &#123;</span><br><span class="line">     addString(result, &apos;B&apos;, result =&gt; &#123;</span><br><span class="line">       addString(result, &apos;C&apos;, result =&gt; &#123;</span><br><span class="line">         console.log(result);</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"> addAll();</span><br></pre></td></tr></table></figure><h2 id="Promises-1"><a href="#Promises-1" class="headerlink" title="Promises"></a>Promises</h2><figure class="highlight plain"><figcaption><span>6</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function addString(previous, current)&#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      setTimeout(</span><br><span class="line">        () =&gt; &#123;</span><br><span class="line">          resolve(previous + &apos; &apos; + current)</span><br><span class="line">        &#125;,</span><br><span class="line">        Math.floor(Math.random() * 100) + 1</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function addAll()&#123;</span><br><span class="line">    addString(&apos;&apos;, &apos;A&apos;)</span><br><span class="line">      .then(result =&gt; &#123;</span><br><span class="line">        return addString(result, &apos;B&apos;)</span><br><span class="line">      &#125;)</span><br><span class="line">      .then(result =&gt; &#123;</span><br><span class="line">        return addString(result, &apos;C&apos;)</span><br><span class="line">      &#125;)</span><br><span class="line">      .then(result =&gt; &#123;</span><br><span class="line">        console.log(result)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  addAll();</span><br></pre></td></tr></table></figure><p>Promise的可读性更强了，但如果继续向链中增加内容，依然会有很多括号。</p><h2 id="Await"><a href="#Await" class="headerlink" title="Await"></a>Await</h2><figure class="highlight plain"><figcaption><span>6</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//  addString函数和Promises相同</span><br><span class="line">  function addString(previous, current)&#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      setTimeout(</span><br><span class="line">        () =&gt; &#123;</span><br><span class="line">          resolve(previous + &apos; &apos; + current)</span><br><span class="line">        &#125;,</span><br><span class="line">        Math.floor(Math.random() * 100) + 1</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  async function addAll()&#123;</span><br><span class="line">    let toPrint = &apos;&apos;;</span><br><span class="line">    toPrint = await addString(toPrint, &apos;A&apos;);</span><br><span class="line">    toPrint = await addString(toPrint, &apos;B&apos;);</span><br><span class="line">    toPrint = await addString(toPrint, &apos;C&apos;);</span><br><span class="line">    console.log(toPrint);</span><br><span class="line">  &#125;</span><br><span class="line">  addAll()</span><br></pre></td></tr></table></figure><p>完美。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;假设一个函数，每隔一段随机时间后打印一个字符串&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;figcaption&gt;&lt;span&gt;6&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function printString(string)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setTimeout(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      ()=&amp;gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        console.log(string)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Math.floor(Math.random() * 100) + 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  现在，我们尝试着按顺序打印a b c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function printAll()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printString(&amp;quot;A&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printString(&amp;quot;B&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printString(&amp;quot;C&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;printAll();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;每次调用printAll时，你会注意到A B C以不同的随机顺序打印。这是因为这些函数是异步的，每个函数按顺序执行，但每个函数都独立于它自己的setTimeout。在开始之前，他们不会等待最后一个功能完成。&lt;/p&gt;
    
    </summary>
    
      <category term="Web开发" scheme="http://zyqvizzz.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="http://zyqvizzz.github.io/tags/JavaScript/"/>
    
      <category term="Async" scheme="http://zyqvizzz.github.io/tags/Async/"/>
    
  </entry>
  
  <entry>
    <title>JS中函数与对象之间的关系</title>
    <link href="http://zyqvizzz.github.io/JS%E4%B8%AD%E5%87%BD%E6%95%B0%E4%B8%8E%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>http://zyqvizzz.github.io/JS中函数与对象之间的关系/</id>
    <published>2018-08-08T06:18:09.000Z</published>
    <updated>2018-08-14T07:14:20.458Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>函数的作用是帮我们编写更少的代码，并阻止我们重复工作。</p></blockquote><p>函数是JavaScript中的主要概念之一，同时函数也是任何编程语言的基本特性。但和一些基于类的语言如Java或PHP不同的是，ES6之前的JavaScript并不遵循基于类的结构，而是遵循基于原型的继承，这很容易会让人感到混乱。</p><p>在JavaScript中，函数有一个额外的工作要执行：创建对象。正如我们所知道的那样，JavaScript基于原型的继承，但我们依然需要创建一个对象，这样我们才能够将相关的逻辑组合到一起。</p><a id="more"></a><p>那么我们如何从函数中创建对象呢？使用关键字new。为此，我们需要创建一个被称作构造函数的东西。</p><p>函数在本质上是一个对象，它具有两个特殊的属性：名称和代码。如果它被命名，那么名称将存储在name属性中，而我们要执行的代码将存储在代码中。当我们调用函数时，JavaScript将会在代码属性里执行代码段。</p><p>写一个简单的函数看看控制台里打印出了什么。</p><p><img src="https://upload-images.jianshu.io/upload_images/3396508-7b5b7f0191fc0cff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输出结果"></p><p>在控制台里，Window对象中的example有一个name属性，属性名称为”example”。当我们用new关键字调用这个函数之前，这个函数只保持为普通函数。当使用new关键字调用时，我们调用的是prototype.constructor方法，该方法可以从函数中实例化一个新的对象。</p><p>由于函数也是对象的一种，所以我们也可以在example函数中附加一些属性和方法。方法存储在函数的prototype属性中，而不是以单个对象的方式存在的，这些方法对于此函数创建的所有实例对象都是通用的。这是为了将所有方法保存在同一个位置，有助于减少对象的内存占用。</p><p>示例代码如下：</p><figure class="highlight javascript"><figcaption><span>1.8</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> ep = <span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  ep.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>, my age is <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> ep1 = <span class="keyword">new</span> ep(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(ep1);</span><br></pre></td></tr></table></figure><p>查看控制台中输出：</p><p><img src="https://upload-images.jianshu.io/upload_images/3396508-c6824f87901def27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输出结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;函数的作用是帮我们编写更少的代码，并阻止我们重复工作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;函数是JavaScript中的主要概念之一，同时函数也是任何编程语言的基本特性。但和一些基于类的语言如Java或PHP不同的是，ES6之前的JavaScript并不遵循基于类的结构，而是遵循基于原型的继承，这很容易会让人感到混乱。&lt;/p&gt;
&lt;p&gt;在JavaScript中，函数有一个额外的工作要执行：创建对象。正如我们所知道的那样，JavaScript基于原型的继承，但我们依然需要创建一个对象，这样我们才能够将相关的逻辑组合到一起。&lt;/p&gt;
    
    </summary>
    
      <category term="Web开发" scheme="http://zyqvizzz.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="http://zyqvizzz.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS中的数据结构：栈、队列和链表 -- 链表</title>
    <link href="http://zyqvizzz.github.io/JS%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84:%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E9%93%BE%E8%A1%A8%20--%20%E9%93%BE%E8%A1%A8/"/>
    <id>http://zyqvizzz.github.io/JS中的数据结构:栈、队列和链表 -- 链表/</id>
    <published>2018-07-16T10:31:09.000Z</published>
    <updated>2018-08-15T09:19:08.577Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://zyqvizzz.github.io/JS%E4%B8%AD%E7%9A%84%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E9%93%BE%E8%A1%A8%20--%20%E6%A0%88/">JS中的数据结构：栈、队列和链表 – 栈</a></li><li><a href="https://zyqvizzz.github.io/JS%E4%B8%AD%E7%9A%84%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E9%93%BE%E8%A1%A8--%E9%98%9F%E5%88%97/">JS中的数据结构：栈、队列和链表 – 队列</a></li></ul><p>我们之前讨论了队列和栈，这两种类型都很简单，易于实现和使用。但实际上，没有任何一种数据结构能够适应所有的情况。在某些情况下，队列和栈被证明效率不高，我们还需要更高级类型的帮助。</p><p>链表（Linked List）就是其中之一。</p><a id="more"></a><h2 id="什么是链表？"><a href="#什么是链表？" class="headerlink" title="什么是链表？"></a>什么是链表？</h2><p>首先，想学习链表，我们需要弄懂一个概念。指针。指针在很多语言中（C/C++）都是非常重要的概念。那什么是指针呢？</p><blockquote><p>指针表示的是内存中某个位置的地址。换句话说，<strong>指针是一个变量</strong>，通过它可以修改/读取另一个变量。</p></blockquote><p>举一个例子：手机号码。我们可以认为它指向的是其所有者，手机的主人可以去世界上的任何地方，但是手机总是指向他。</p><blockquote><p>链表是所有元素按线性顺序排列的结构，由存储在每个元素中的指针所确定。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/3396508-f76f40c0e001de1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="链表"></p><p>与数组不同，链表是动态集合的灵活表示，链表中的元素不需要在同一内存块中分配（如：在同一个数组中），但可以用指针连接起来，形成一个list。</p><p>继续手机的例子：<strong>A和B是两个独立的个体，但当A把B的手机号码保存在通讯录之后，A和B就产生了关系，也就是说，A和B在此时形成了链表；</strong>接着，B保存C的号码，C保存了D的号码······</p><p>链表有几种类型，在本文范围里，我们只提到两种主要类型，单向链表和双向链表。</p><ul><li><strong>单向链表</strong>：最简单的链接结构。每个节点中都保存了指向下一个节点的指针，其中head指针将指向第一个成为<strong>头节点</strong>，最后一个节点的指针则指向null作为结束。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/3396508-1123844476e050dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单向链表"></p><ul><li><strong>双向链表</strong>：类似于单向链表，但除了指向下一个节点的指针外，每个节点中还保存了指向前一个节点的指针。这同样可以用手机的例子来解释：A保存了B的号码，B保存了C的号码，也保存了A的号码，以此类推。和单向链表相同的是，双向链表也有一个指向头节点的head指针，最后一个节点的指针也指向null。与此同时，双向链表由于是循环的，所以它的头节点中也会保存一个指向null的指针。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/3396508-88e7a44064983123.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="双向链表"></p><h2 id="链表支持哪些操作？"><a href="#链表支持哪些操作？" class="headerlink" title="链表支持哪些操作？"></a>链表支持哪些操作？</h2><p>一般来说，每个链表结构都支持三个主要的基本操作：</p><ul><li><strong>Search</strong>：根据值或位置搜索一个节点。</li><li><strong>Insert</strong>：在链表中插入一个新的节点。</li><li><strong>Delete</strong>：根据值或位置删除一个节点。</li></ul><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>JavaScript被设计为一门按引用传递的语言（也有说法是JavaScript中其实都是按值传递的，这里暂且不多做讨论），它表示除了基本类型之外，其他类型（数组，对象，函数）都是通过引用（指针）传递的。</p><p>有了这个，实现一个链表就很简单了。</p><p>我们首先需要声明一个Node对象，它用来表示链表中的节点，其中包括：</p><ol><li>本身的数据</li><li>指向下一个节点的指针对象</li><li>指向前一个节点的指针对象（双向链表）</li></ol><p><strong>tips</strong>：如果Node对象是双链表的头部，则它的前一个指针指向null，同理，尾部的下一个指针也指向null。</p><p>大概是这样的：</p><figure class="highlight plain"><figcaption><span>6</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Node(value)&#123;</span><br><span class="line">this.value = value;</span><br><span class="line">this.next = undefined;</span><br><span class="line"></span><br><span class="line">// 双链表</span><br><span class="line">this.prev = undefined;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们来初始化一个链表类。</p><p><strong>单向链表</strong></p><figure class="highlight plain"><figcaption><span>6</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function SingleLinkedList()&#123;</span><br><span class="line">// 保留一个指向头结点的指针</span><br><span class="line">this.head = undefined;</span><br><span class="line">this.length = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双向链表</strong></p><figure class="highlight plain"><figcaption><span>6</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function DoubleLinkedList()&#123;</span><br><span class="line">// 保留一个指向头结点的指针</span><br><span class="line">this.head = undefined;</span><br><span class="line">this.length = 0;</span><br><span class="line">// 多了一个指向尾节点的指针</span><br><span class="line">this.tail = undefined;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常还需要增加三个方法：</p><p><strong>Insert</strong>：插入到链表的开头</p><figure class="highlight plain"><figcaption><span>6</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Insert(item)&#123;</span><br><span class="line">if(!item) return;</span><br><span class="line">// 把item实例化为一个node</span><br><span class="line">var node = new Node(item);</span><br><span class="line"></span><br><span class="line">if(head)&#123;</span><br><span class="line">node.next = head;</span><br><span class="line">&#125;</span><br><span class="line">head = node;</span><br><span class="line">length++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双链表的情况还需要更新prev</p><figure class="highlight plain"><figcaption><span>6</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if(head)&#123;</span><br><span class="line">node.next = head;</span><br><span class="line">head.prev = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(!tail)&#123;</span><br><span class="line">tail = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Delete</strong>：删除的总体原则就是改变指针的指向</p><p>单向链表：思路 =&gt; 遍历链表，如果找到目标节点，就把上一个节点的next指针指向目标节点的下一个节点。</p><figure class="highlight plain"><figcaption><span>6</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 单链表</span><br><span class="line">function Delete(value)&#123;</span><br><span class="line">var curr = head; // 头部作为检索起点</span><br><span class="line">if(head.value === value)&#123;</span><br><span class="line">head = head.next;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while(curr)&#123;</span><br><span class="line">if(curr.next)&#123;</span><br><span class="line">var next = curr.next</span><br><span class="line">if(curr.value === value)&#123;</span><br><span class="line">curr.next = next.next;</span><br><span class="line"></span><br><span class="line">length--;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">curr = curr.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双向链表：思路 =&gt; 遍历链表，如果找到目标节点，就把上一个节点的next指针和下一个节点的prev指针更新。</p><figure class="highlight plain"><figcaption><span>6</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function Delete(value) &#123;</span><br><span class="line">  var curr = head;</span><br><span class="line">  while (curr) &#123;</span><br><span class="line">    if (curr.value === value)&#123;</span><br><span class="line">      var prev = curr.prev, next = curr.next;</span><br><span class="line">      if (prev)&#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">      &#125;</span><br><span class="line">      else&#123;</span><br><span class="line">        head = next;</span><br><span class="line">      &#125;</span><br><span class="line">      if (next)&#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">      &#125;</span><br><span class="line">      else&#123;</span><br><span class="line">        tail = prev;</span><br><span class="line">      &#125;</span><br><span class="line">      length--;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Search</strong></p><figure class="highlight plain"><figcaption><span>6</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Search(value) &#123;</span><br><span class="line">  var curr = head;</span><br><span class="line">  var found = undefined;</span><br><span class="line">  while (curr) &#123;</span><br><span class="line">    if (curr.value === value) &#123;</span><br><span class="line">      found = curr;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = curr.next;</span><br><span class="line">  &#125;</span><br><span class="line">  return found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight plain"><figcaption><span>6</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">function Node(value) &#123;</span><br><span class="line">  this.value = value;</span><br><span class="line">  this.next = undefined;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SingleLinkedList() &#123;</span><br><span class="line">  var head = undefined;</span><br><span class="line">  var length = 0;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    insert: function(item) &#123;</span><br><span class="line">      if (!item) return;</span><br><span class="line"></span><br><span class="line">      var node = new Node(item);</span><br><span class="line"></span><br><span class="line">      if (head) &#123;</span><br><span class="line">        node.next = head;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      head = node;</span><br><span class="line">      length++;</span><br><span class="line">    &#125;,</span><br><span class="line">    delete: function(value) &#123;</span><br><span class="line">      var curr = head;</span><br><span class="line"></span><br><span class="line">      if (head.value === value) &#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      while (curr) &#123;</span><br><span class="line">        if (curr.next) &#123;</span><br><span class="line">          var next = curr.next;</span><br><span class="line"></span><br><span class="line">          if (next.value === value) &#123;</span><br><span class="line">            curr.next = next.next;</span><br><span class="line">            length--;</span><br><span class="line">            break;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        curr = curr.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    search: function(value) &#123;</span><br><span class="line">      var curr = head;</span><br><span class="line">      var found = undefined;</span><br><span class="line"></span><br><span class="line">      while (curr) &#123;</span><br><span class="line">        if (curr.value === value) &#123;</span><br><span class="line">          found = curr;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        curr = curr.next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return found;</span><br><span class="line">    &#125;,</span><br><span class="line">    get size() &#123;</span><br><span class="line">      return length;</span><br><span class="line">    &#125;,</span><br><span class="line">    print: function() &#123;</span><br><span class="line">      var result = [];</span><br><span class="line"></span><br><span class="line">      var curr = head;</span><br><span class="line">      while (curr) &#123;</span><br><span class="line">        result.push(curr.value);</span><br><span class="line"></span><br><span class="line">        curr = curr.next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双向链表</strong></p><figure class="highlight plain"><figcaption><span>6</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">function Node(value) &#123;</span><br><span class="line">  this.value = value;</span><br><span class="line">  this.next = undefined;</span><br><span class="line">  this.prev = undefined;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function DoubleLinkedList() &#123;</span><br><span class="line">  var head = undefined;</span><br><span class="line">  var tail = undefined;</span><br><span class="line">  var length = 0;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    insert: function(item) &#123;</span><br><span class="line">      if (!item) return;</span><br><span class="line"></span><br><span class="line">      var node = new Node(item);</span><br><span class="line"></span><br><span class="line">      if (head) &#123;</span><br><span class="line">        node.next = head;</span><br><span class="line">        head.prev = node;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      head = node;</span><br><span class="line"></span><br><span class="line">      if (!tail)&#123;</span><br><span class="line">        tail = node;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      length++;</span><br><span class="line">    &#125;,</span><br><span class="line">    delete: function(value) &#123;</span><br><span class="line">      var curr = head;</span><br><span class="line"></span><br><span class="line">      while (curr) &#123;</span><br><span class="line">        if (curr.value === value)&#123;</span><br><span class="line">          var prev = curr.prev, next = curr.next;</span><br><span class="line"></span><br><span class="line">          if (prev)&#123;</span><br><span class="line">            prev.next = next;</span><br><span class="line">          &#125;</span><br><span class="line">          else&#123;</span><br><span class="line">            head = next;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (next)&#123;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">          &#125;</span><br><span class="line">          else&#123;</span><br><span class="line">            tail = prev;</span><br><span class="line">          &#125;</span><br><span class="line">          length--;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        curr = curr.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    search: function(value) &#123;</span><br><span class="line">      var curr = head;</span><br><span class="line">      var found = undefined;</span><br><span class="line"></span><br><span class="line">      while (curr) &#123;</span><br><span class="line">        if (curr.value === value) &#123;</span><br><span class="line">          found = curr;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        curr = curr.next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return found;</span><br><span class="line">    &#125;,</span><br><span class="line">    get size() &#123;</span><br><span class="line">      return length;</span><br><span class="line">    &#125;,</span><br><span class="line">    print: function() &#123;</span><br><span class="line">      var result = [];</span><br><span class="line"></span><br><span class="line">      var curr = head;</span><br><span class="line">      while (curr) &#123;</span><br><span class="line">        result.push(curr.value);</span><br><span class="line"></span><br><span class="line">        curr = curr.next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表的优缺点"><a href="#链表的优缺点" class="headerlink" title="链表的优缺点"></a>链表的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>当我们需要在未知长度的列表上进行大量插入和删除操作时，使用链表比数组更加简单。</li><li>数据量大时，移动指针比移动元素速度更快。</li><li>我们可以轻易的拆分或组合不同的列表。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>链表需要额外的空间来存储指针（地址），也就是说它需要占用更多的内存。</li><li>无法真正的随机访问列表中的元素，因为链表里没有索引。</li><li>数组拥有更好的缓存性能</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zyqvizzz.github.io/JS%E4%B8%AD%E7%9A%84%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E9%93%BE%E8%A1%A8%20--%20%E6%A0%88/&quot;&gt;JS中的数据结构：栈、队列和链表 – 栈&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zyqvizzz.github.io/JS%E4%B8%AD%E7%9A%84%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E9%93%BE%E8%A1%A8--%E9%98%9F%E5%88%97/&quot;&gt;JS中的数据结构：栈、队列和链表 – 队列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们之前讨论了队列和栈，这两种类型都很简单，易于实现和使用。但实际上，没有任何一种数据结构能够适应所有的情况。在某些情况下，队列和栈被证明效率不高，我们还需要更高级类型的帮助。&lt;/p&gt;
&lt;p&gt;链表（Linked List）就是其中之一。&lt;/p&gt;
    
    </summary>
    
      <category term="Web开发" scheme="http://zyqvizzz.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="http://zyqvizzz.github.io/tags/JavaScript/"/>
    
      <category term="数据结构" scheme="http://zyqvizzz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>JS中的数据结构：栈、队列和链表 -- 栈</title>
    <link href="http://zyqvizzz.github.io/JS%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84:%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E9%93%BE%E8%A1%A8%20--%20%E6%A0%88/"/>
    <id>http://zyqvizzz.github.io/JS中的数据结构:栈、队列和链表 -- 栈/</id>
    <published>2018-07-13T10:31:09.000Z</published>
    <updated>2018-08-14T10:34:13.779Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS中的栈、队列和链表-–-栈"><a href="#JS中的栈、队列和链表-–-栈" class="headerlink" title="JS中的栈、队列和链表 – 栈"></a>JS中的栈、队列和链表 – 栈</h1><p>接着上一篇 <a href="https://zyqvizzz.github.io/JS%E4%B8%AD%E7%9A%84%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E9%93%BE%E8%A1%A8--%E9%98%9F%E5%88%97/">《JS中的栈、队列和链表 – 队列》</a>的讨论，今天我们将用JS的方式实现栈。</p><h2 id="什么是栈？"><a href="#什么是栈？" class="headerlink" title="什么是栈？"></a>什么是栈？</h2><p>还是引用《JS高级编程》里的比喻来形容，栈就像叠盘子，一个一个往上叠，最后一个叠上去的，需要第一个拿出来。所以栈也是一个动态集合：新的元素被压入栈的最顶部；需要删除的元素将从栈的最顶部被弹出；删除的操作遵循LIFO（后进先出）的原则。</p><a id="more"></a><p>还有一个例子叫做链式活动执行，比如说，你需要组装一台电脑，为了完成这件事，你首先需要购买所有的计算机部件，但在此之前，你需要执行研究以获得最好的计算机部件，每个活动都是连接起来的，当前活动完成执行后其他活动才能继续。因此活动将如下图表示：</p><p><img src="https://upload-images.jianshu.io/upload_images/3396508-0556733169fb9601.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="活动执行"></p><p>在这种情况下使用栈可确保在完成主要活动完成之前，我们不会错过任何所需的子活动。</p><h2 id="如何实现栈结构？"><a href="#如何实现栈结构？" class="headerlink" title="如何实现栈结构？"></a>如何实现栈结构？</h2><ul><li>基本结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stack&#123;</span><br><span class="line">1 将索引初始化为0</span><br><span class="line">2 声明一个Object用来存储所有堆栈的位置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>push方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Push(item)&#123;</span><br><span class="line"> 1 将项目分配给可用的顶级索引</span><br><span class="line"> 2 增加栈的大小 - 或准备下一个顶部的索引</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>pop方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pop()&#123;</span><br><span class="line"> 1 检查栈是否为空，如果是则返回</span><br><span class="line"> 2 减少栈的大小 - 也就是当前的顶部索引</span><br><span class="line"> 3 获取当前的顶部索引</span><br><span class="line"> 4 通过Object Prototype的删除操作将其从存储容器中删除</span><br><span class="line"> 5 返回元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈溢出和栈下溢"><a href="#栈溢出和栈下溢" class="headerlink" title="栈溢出和栈下溢"></a>栈溢出和栈下溢</h3><p>我们经常能听到栈溢出，那什么是栈溢出呢？百度百科的解释是：栈溢出就是不顾堆栈中分配的局部数据块大小，向该数据块写入了过多的数据，导致数据越界，结果覆盖了别的数据。当栈的大小超过允许的最大数量时会发生栈溢出，这个大小通常是事先定义好的。</p><p>最常见的例子是无限递归，如果递归过程中的停止条件没有明确定义，那么这个进程就会无限运行，导致栈溢出并崩溃。</p><p>除了栈溢出，还有一个栈下溢的概念，这个相比溢出要更容易理解：栈下溢就是弹出空栈时的状态。这是可以避免的问题，因为我们在执行pop()方法之前通常会进行非空的检查。</p><h2 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h2><figure class="highlight javascript"><figcaption><span>1.8</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> stack = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> stackSize = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    push(item)&#123;</span><br><span class="line">      stack[stackSize] = item;</span><br><span class="line">      stackSize++;</span><br><span class="line">    &#125;,</span><br><span class="line">    pop()&#123;</span><br><span class="line">      <span class="comment">// 空栈检查</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.isEmpty())&#123;<span class="keyword">return</span> <span class="literal">undefined</span>;&#125;</span><br><span class="line">      stackSize--;</span><br><span class="line">      <span class="keyword">let</span> item = stack[stackSize]</span><br><span class="line">    &#125;,</span><br><span class="line">    isEmpty()&#123;</span><br><span class="line">      <span class="keyword">return</span> stackSize === <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    size()&#123;</span><br><span class="line">      <span class="keyword">return</span> stackSize;</span><br><span class="line">    &#125;,</span><br><span class="line">    print()&#123;</span><br><span class="line">      <span class="keyword">let</span> result = [];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> stack)&#123;</span><br><span class="line">        result.unshift(stack[key])</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么不使用数组呢？"><a href="#为什么不使用数组呢？" class="headerlink" title="为什么不使用数组呢？"></a>为什么不使用数组呢？</h2><p>和实现队列时的原因一样。</p><ul><li>Array.prototype里的大部分操作的时间复杂度都是O(n)</li><li>数组因为要保持顺序，所以它会占用一块内存</li><li>最重要的是，JS里万物皆对象。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JS中的栈、队列和链表-–-栈&quot;&gt;&lt;a href=&quot;#JS中的栈、队列和链表-–-栈&quot; class=&quot;headerlink&quot; title=&quot;JS中的栈、队列和链表 – 栈&quot;&gt;&lt;/a&gt;JS中的栈、队列和链表 – 栈&lt;/h1&gt;&lt;p&gt;接着上一篇 &lt;a href=&quot;https://zyqvizzz.github.io/JS%E4%B8%AD%E7%9A%84%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E9%93%BE%E8%A1%A8--%E9%98%9F%E5%88%97/&quot;&gt;《JS中的栈、队列和链表 – 队列》&lt;/a&gt;的讨论，今天我们将用JS的方式实现栈。&lt;/p&gt;
&lt;h2 id=&quot;什么是栈？&quot;&gt;&lt;a href=&quot;#什么是栈？&quot; class=&quot;headerlink&quot; title=&quot;什么是栈？&quot;&gt;&lt;/a&gt;什么是栈？&lt;/h2&gt;&lt;p&gt;还是引用《JS高级编程》里的比喻来形容，栈就像叠盘子，一个一个往上叠，最后一个叠上去的，需要第一个拿出来。所以栈也是一个动态集合：新的元素被压入栈的最顶部；需要删除的元素将从栈的最顶部被弹出；删除的操作遵循LIFO（后进先出）的原则。&lt;/p&gt;
    
    </summary>
    
      <category term="Web开发" scheme="http://zyqvizzz.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="http://zyqvizzz.github.io/tags/JavaScript/"/>
    
      <category term="数据结构" scheme="http://zyqvizzz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>JS中的数据结构：栈、队列和链表 -- 队列</title>
    <link href="http://zyqvizzz.github.io/JS%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84:%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E9%93%BE%E8%A1%A8%20--%20%E9%98%9F%E5%88%97/"/>
    <id>http://zyqvizzz.github.io/JS中的数据结构:栈、队列和链表 -- 队列/</id>
    <published>2018-07-12T08:18:09.000Z</published>
    <updated>2018-08-14T10:34:13.776Z</updated>
    
    <content type="html"><![CDATA[<p>栈和队列是数据结构里的基本概念之一。所以今天讨论的内容是如何在JavaScript中实现一个队列。</p><h2 id="什么是队列"><a href="#什么是队列" class="headerlink" title="什么是队列"></a>什么是队列</h2><p>顾名思义，就是排队的意思。之前看《JS高级编程》时里面好像举了一个买电影票的例子，我们排队买票，第一个人买完了票从队伍的最前面离开，新来的人要站在队伍的最后一个。</p><p>所以，在数据结构语言中，队列是一个动态的集合：其中新元素将被插入到队列的末尾(入队 ENQUEUE)；并且要从队列的头部删除元素(出队 DEQUEUE)；同时EnQueue和DeQueue是队列结构需要支持的两个主要操作。</p><a id="more"></a><p>删除的操作基于FIFO(先进先出)原则，先一步入队的元素必须先一步出队。</p><p>举一个作业调度的例子。</p><p><img src="https://upload-images.jianshu.io/upload_images/3396508-5db375659deaf5ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="队列"></p><p>这样的调度方式确保了任何工作都不会被遗忘或者等待太久。</p><h2 id="如何在JS里使用队列"><a href="#如何在JS里使用队列" class="headerlink" title="如何在JS里使用队列"></a>如何在JS里使用队列</h2><p>在JS中实现Queue的最简单的方法是将数组作为容器存储。使用Array.shift()方法可以移除并返回第一个元素，简单但并不高效。因为：</p><ul><li>shift()的时间复杂度是O(n)，n是队列的长度，但是DeQueue()的目标运行时间应为O(1)</li><li>Array.prototype里的大部分操作的时间复杂度都是O(n)</li><li>数组是索引集合，所有的数据都被分配到内存中。如果队列过大，则每次更改都将移动大块内存以使用索引来保持数组可访问。</li></ul><p>从时间和准确性的角度上看，数组并不是最好的存储容器，那么有比数组更好的存储容器吗？对象。JS里的一切不都是对象吗？</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ul><li><p>队列的基本结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Queue()&#123;</span><br><span class="line">  // 声明一个对象作为队列的存储容器</span><br><span class="line">  // 声明头尾两端的索引值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>EnQueue的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EnQueue: function(item)&#123;</span><br><span class="line">  // 将入队的值分配一个尾部索引</span><br><span class="line">  // 尾部的索引值递增</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>DeQueue的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DeQueue: function()&#123;</span><br><span class="line">  // 检查队列是否为空</span><br><span class="line">  // 获取当前的头部索引指向的值</span><br><span class="line">  // 删除数组头部元素</span><br><span class="line">  // 将下一个索引变为头部索引</span><br><span class="line"></span><br><span class="line">  // 为空则重置, 确保头尾索引不会过大</span><br><span class="line"></span><br><span class="line">  // 返回删除的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight javascript"><figcaption><span>1.8</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> storage = &#123;&#125;,</span><br><span class="line">    top = <span class="number">0</span>,</span><br><span class="line">    end= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    enQueue: <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">      storage[end] = item;</span><br><span class="line">      end++;</span><br><span class="line">    &#125;,</span><br><span class="line">    deQueue: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> size = end - top;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> item = storage[top];</span><br><span class="line">      <span class="keyword">delete</span> storage[top];</span><br><span class="line">      top++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (top === end)&#123;</span><br><span class="line">        top = <span class="number">0</span>;</span><br><span class="line">        end = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> item;</span><br><span class="line">    &#125;,</span><br><span class="line">    size: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> end - top;</span><br><span class="line">    &#125;,</span><br><span class="line">    peek: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> storage[end - <span class="number">1</span>];</span><br><span class="line">    &#125;,</span><br><span class="line">    print: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> storage)&#123;</span><br><span class="line">        result.push(storage[key]);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，访问Object的属性需要O(1)时间，因此EnQueue和DeQueue方法每个都将花费固定的时间，不会因队列大小的变化而变化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;栈和队列是数据结构里的基本概念之一。所以今天讨论的内容是如何在JavaScript中实现一个队列。&lt;/p&gt;
&lt;h2 id=&quot;什么是队列&quot;&gt;&lt;a href=&quot;#什么是队列&quot; class=&quot;headerlink&quot; title=&quot;什么是队列&quot;&gt;&lt;/a&gt;什么是队列&lt;/h2&gt;&lt;p&gt;顾名思义，就是排队的意思。之前看《JS高级编程》时里面好像举了一个买电影票的例子，我们排队买票，第一个人买完了票从队伍的最前面离开，新来的人要站在队伍的最后一个。&lt;/p&gt;
&lt;p&gt;所以，在数据结构语言中，队列是一个动态的集合：其中新元素将被插入到队列的末尾(入队 ENQUEUE)；并且要从队列的头部删除元素(出队 DEQUEUE)；同时EnQueue和DeQueue是队列结构需要支持的两个主要操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Web开发" scheme="http://zyqvizzz.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JavaScript" scheme="http://zyqvizzz.github.io/tags/JavaScript/"/>
    
      <category term="数据结构" scheme="http://zyqvizzz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>第零章 武库大火事件</title>
    <link href="http://zyqvizzz.github.io/%E6%AD%A6%E5%BA%93%E5%A4%A7%E7%81%AB%E4%BA%8B%E4%BB%B600/"/>
    <id>http://zyqvizzz.github.io/武库大火事件00/</id>
    <published>2018-06-18T06:18:09.000Z</published>
    <updated>2018-08-14T08:04:59.907Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>书三写，鱼成书，帝成鲁。<br>作：苏住</p></blockquote><h3 id="壹"><a href="#壹" class="headerlink" title="壹"></a>壹</h3><p>元康年间，一桩坊间流言在洛阳城里悄然流传。说陆公子身怀绝技，每至夜冷灯寒，便化身为江洋大盗，在城中兴风作浪。初次听说这个故事的人多半有两种反应，一些人不知道陆公子是谁，也从没在以往的奇闻传说里见过他的影子，他们被这个陌生的人物吸引，完全归功于说书客的妙笔生花；而另一小撮人，他们知道陆公子，甚至有人自称是他的朋友，这些人对故事将信将疑。在他们眼里，陆公子并不是神秘的江湖侠客，只是个无甚特别的平头百姓，住在洛阳城内某块不甚平整的泥土地里。这里以前没有过传说，以后也绝不会有。</p><a id="more"></a><p>在造访陆公子之前，我已在邻里们的耳传口授中对他的性格模样有了一些粗浅的感观。大概是这样一个人：一介书生，白净面皮，偏爱素色衣衫，样式多为腰窄袖宽的吴服旧制；有服散习惯，洛阳城内买不到他的方子，所以有专门为他供货的外地客商；自己酿酒，酒后行文，但未听说有公开发表于世的文章；不接受文人圈子的邀请，不参与任何形式的清议；起居不定，断绝交游，只有在节庆期间才偶尔现身于坊外的花灯庙会上，照旧孤身一人；更多能见到他的机会是找他写信–陆公子每逢初一，初十，二十这三日执笔，为邻居们代写家书，并象征性的收取少量钱帛。因此，尽管人们对他的生平知之甚少，他亦极少与人主动往来，但这丝毫不能抵消他在吴人坊里所获得的绝好名声。</p><p>“吴人坊，乃是洛阳城四夷坊之一，地处城东一隅，距离马市不远，从洛水桥出发步行赶往此地，脚程约半个时辰。三年前，也就是陆公子来到洛阳的第二年，他一头扎进吴人坊，从此与外界音信相绝。”</p><p>说书客的情报非常准确，我依照故事中的描述，很快便在这座此前闻所未闻的吴人坊中寻找到了陆公子的府邸——说是府邸，未免有些夸大之嫌，因为此时我不知该以陆公子的身份作为标准，还是该以眼前的客观事实作为依据——就暂且称之为屋邸吧。</p><p>他的屋邸很好认，是吴人坊里少数顶上有瓦的房子。单进单出，从外部的墙围构造推测，里面没有左右厢房，只有一间朝南的堂屋和一座相对宽敞的院落，堂屋左右是卧室和厨房；似乎唯独在门上多花了心思：院门两旁的一小段护墙高出围墙整体约五尺，向里斜收，和院门连接成为一个颇有礼让的梯形，这大概是为了让门檐和台阶不占用额外道路而特意做出的设计；门檐上没有多余的装饰，四平八稳，朴实而庄重，门前设有两级台阶，阶上间杂着几株错落有致的绣墩草，和坊里其他的民房相比，这里始终透着些文气，但又并不突兀。</p><p>不难发现，陆公子的住宅有一种均衡克制的气氛，甚至在规格上暗降一等，而之所以这么做，多半是出于他的友善性格，他不希望邻居们因为他的存在而感到不安。这是一种君子风度。所以，为了还以同样的礼数，在叩响陆家的院门之前，我在头脑中对陆公子的生平做了一次额外的整理：</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;书三写，鱼成书，帝成鲁。&lt;br&gt;作：苏住&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;壹&quot;&gt;&lt;a href=&quot;#壹&quot; class=&quot;headerlink&quot; title=&quot;壹&quot;&gt;&lt;/a&gt;壹&lt;/h3&gt;&lt;p&gt;元康年间，一桩坊间流言在洛阳城里悄然流传。说陆公子身怀绝技，每至夜冷灯寒，便化身为江洋大盗，在城中兴风作浪。初次听说这个故事的人多半有两种反应，一些人不知道陆公子是谁，也从没在以往的奇闻传说里见过他的影子，他们被这个陌生的人物吸引，完全归功于说书客的妙笔生花；而另一小撮人，他们知道陆公子，甚至有人自称是他的朋友，这些人对故事将信将疑。在他们眼里，陆公子并不是神秘的江湖侠客，只是个无甚特别的平头百姓，住在洛阳城内某块不甚平整的泥土地里。这里以前没有过传说，以后也绝不会有。&lt;/p&gt;
    
    </summary>
    
      <category term="小说" scheme="http://zyqvizzz.github.io/categories/%E5%B0%8F%E8%AF%B4/"/>
    
    
      <category term="假面生死簿" scheme="http://zyqvizzz.github.io/tags/%E5%81%87%E9%9D%A2%E7%94%9F%E6%AD%BB%E7%B0%BF/"/>
    
  </entry>
  
  <entry>
    <title>ES6：Map和Object</title>
    <link href="http://zyqvizzz.github.io/ES6%20MapvsObject/"/>
    <id>http://zyqvizzz.github.io/ES6 MapvsObject/</id>
    <published>2018-05-12T11:45:20.000Z</published>
    <updated>2018-08-24T03:02:56.104Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="什么是Map"><a href="#什么是Map" class="headerlink" title="什么是Map"></a>什么是Map</h3><p>Map是一种数据集合类型，其中，数据以“键值对”的形式存储，其中包含一个唯一键和对应的值，由于每个存储秘钥的唯一性，因此不存在重复的键值对。</p><p>我们一定看过真实的地图，比如世界地图，地图上分布着所有国家的土地，它们有着不同的形状，当我需要找到其中某一个国家时，我不需要知道这个国家的形状是鸡还是熊，我只需要知道这个国家的名字即可。</p><p>在编程的世界里，Map拥有和地图相似的功能——快速检索数据。</p><p>例如: <code>{(“China”, “中国”), (“USA”, “美国”), (“UK”, “英国”)}</code></p><p>每个“对”都遵循这样的格式：(key, value)。它们可以是任何数据类型，不仅限于字符串或整数。</p><h3 id="什么是Object"><a href="#什么是Object" class="headerlink" title="什么是Object"></a>什么是Object</h3><p>Object是JavaScript中内置的原型，并且所有的JS对象都是Object的实例，包括Map。</p><p>例如: <code>{1: ‘smile’, 2: ‘cry’, 42: ‘happy’}</code></p><p>因此，我们可以看出Object和Map基于相同的概念——使用键值来存储数据。但它们又是完全不同的：</p><ul><li>键：在Object中，它遵循普通字典的规则，必须是简单类型（整数或字符串）。但在Map中，它可以是任何数据类型，可以是数组，也可以是对象。</li><li>顺序：在Map中，元素是有顺序的，而在Object里则没有。</li><li>继承关系：Map是Object的一个实例，而Object不是。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var map = new Map([[1,2],[3,4]]);</span><br><span class="line">console.log(map instanceof Object); // true</span><br><span class="line"></span><br><span class="line">var obj = new Object();</span><br><span class="line">console.log(obj instanceof Map); // false</span><br></pre></td></tr></table></figure><h2 id="构造Map和Object"><a href="#构造Map和Object" class="headerlink" title="构造Map和Object"></a>构造Map和Object</h2><p><strong>Object</strong></p><p>就像Array一样，Object也是个直肠子，想声明一个Object，你只需要这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">var obj = &#123;id: 1, name: &quot;BaiXS&quot;&#125;</span><br></pre></td></tr></table></figure><p>或者这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object();</span><br><span class="line">var obj = new Object;</span><br><span class="line">// 这两种没区别</span><br></pre></td></tr></table></figure><p>或者这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj = Object.create(null)</span><br></pre></td></tr></table></figure><p>最后一种写法通常来说只适用于特定的情况，像这样：</p><ul><li>你希望选择一个原型对象来继承，而不是定义一个构造函数。所以这是一种继承的方式。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var Pet = &#123;</span><br><span class="line">type: &quot;General&quot;,</span><br><span class="line">display: function()&#123;console.log(this.type);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var Dog = Object.create(Pet);</span><br><span class="line">Dog.type = &quot;Dog&quot;;</span><br><span class="line">Dog.display(); // Dog</span><br><span class="line"></span><br><span class="line">Pet.display(); // 仍然是General</span><br></pre></td></tr></table></figure><p><strong>Map</strong></p><p>另一方面，Map有其内置的构造函数和新语法，只有一种方法可以创建它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var map = new Map();</span><br><span class="line">var map = new Map([1,2], [2,3]); // map = &#123;1=&gt;2, 2=&gt;3&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Map([iterable])</p></blockquote><p>构造函数接收一个数组或可迭代对象，其元素是键值对：[key, value]。</p><p>到现在为止，一切都进行得特别自然。接下来，我们将比较Map/Object的基本功能。</p><h2 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h2><p>对于Map，访问某个元素值是由Map.prototype.get(key)完成的，也就是说，我们得知道能够检测元素值的键。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.get(1) // 2</span><br></pre></td></tr></table></figure><p>类似的，在Object中，我们需要知道key/property以获取元素值，但是使用的是不同的语法：Object.<key>和Object[‘key’]。</key></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.id // 1</span><br><span class="line">obj[&apos;id&apos;] // 1</span><br></pre></td></tr></table></figure><p>检查键是否已在Map中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.has(1); // 返回布尔值</span><br></pre></td></tr></table></figure><p>在Object里，我们得做一些额外的工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var isExist = obj.id === undefined; </span><br><span class="line">// 检查obj是否有之前定义过的属性</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isExist = &apos;id&apos; in obj; // 这也适用于从父级继承到的的属性</span><br></pre></td></tr></table></figure><p>在这种情况下，Map中的语法比Object中的语法更加简洁，更直接。</p><h2 id="添加新元素"><a href="#添加新元素" class="headerlink" title="添加新元素"></a>添加新元素</h2><p>Map支持通过提供Map.prototype.set()来添加新元素，它接受两个参数：key, value。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;h3 id=&quot;什么是Map&quot;&gt;&lt;a href=&quot;#什么是Map&quot; class=&quot;headerlink&quot; title=&quot;什么是Map&quot;&gt;&lt;/a&gt;什
      
    
    </summary>
    
      <category term="Web开发" scheme="http://zyqvizzz.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="ECMAScript 6" scheme="http://zyqvizzz.github.io/tags/ECMAScript-6/"/>
    
      <category term="JavaScript" scheme="http://zyqvizzz.github.io/tags/JavaScript/"/>
    
      <category term="数据结构" scheme="http://zyqvizzz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>开发一款基于Nas星云链的Web APP</title>
    <link href="http://zyqvizzz.github.io/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8ENas%E6%98%9F%E4%BA%91%E9%93%BE%E7%9A%84Web%20APP/"/>
    <id>http://zyqvizzz.github.io/开发一个基于Nas星云链的Web APP/</id>
    <published>2018-05-08T10:31:09.000Z</published>
    <updated>2018-08-15T15:38:29.478Z</updated>
    
    <content type="html"><![CDATA[<p>第一步</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一步&lt;/p&gt;
    
    </summary>
    
      <category term="区块链" scheme="http://zyqvizzz.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="JavaScript" scheme="http://zyqvizzz.github.io/tags/JavaScript/"/>
    
      <category term="区块链" scheme="http://zyqvizzz.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>ES6：Set和Array</title>
    <link href="http://zyqvizzz.github.io/ES6%20SetvsArray/"/>
    <id>http://zyqvizzz.github.io/ES6 SetvsArray/</id>
    <published>2018-05-08T10:31:09.000Z</published>
    <updated>2018-08-20T05:58:19.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Set和Array是什么？"><a href="#Set和Array是什么？" class="headerlink" title="Set和Array是什么？"></a>Set和Array是什么？</h2><p>绝不会有任何一个前端开发者会告诉你说他不熟悉数组(Array)，我们每天都会无数次的和数组打交道，但到底数组是什么呢？</p><blockquote><p>数组对象是使用单独的变量名在内存中存储的一系列的值。</p></blockquote><p>例如：<code>[1,2,3,1]</code></p><p>那什么是set呢？</p><blockquote><p>Set是一种抽象数据类型，只包含不同的元素/对象，而不需要按索引顺序分配</p></blockquote><p>例如：<code>{1，2，3}</code></p><p>根据定义，Array和Set在技术上是两种不同的概念。</p><a id="more"></a><p>在上述的例子中，你也许能发现它们之间的不同之处，虽然不是很明显，但你还是能够发现，Set里的元素都是不重复的，而Array中的元素可以重复。</p><p>另外，Array被定义为“索引集合(indexed collection)”类型的数据结构，Set则被定义为“键值集合(keyed collection)”。顾名思义，索引集合按照索引排序，键值集合是使用key并按照顺序迭代的元素集合。</p><p>我们这篇文章的目的是讨论如何在Array和Set中做出选择，所以下一步是用JS来构建它们。</p><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><h3 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h3><p>在JS里，数组是个非常随性且直接的东西。</p><p>我们可以这样构建一个数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr = [];</span><br><span class="line">let arr = [1,2,3];</span><br></pre></td></tr></table></figure><p>或者使用内置的构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array();</span><br><span class="line">var arr = new Array(1,2,3);</span><br></pre></td></tr></table></figure><p>也可以更特殊一点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr = Array.from(&quot;123&quot;); //[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]</span><br></pre></td></tr></table></figure><p><strong>tip</strong>：建议不要使用new Array()这种方式，因为：</p><ul><li>它的执行速度比普通的[]字面量慢得多。</li><li>[]会节省你的打字时间。</li><li>new Array()可能会让你碰到一些经典的问题。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var arr1 = new Array(10);</span><br><span class="line">// arr1[0] = undefined;</span><br><span class="line">// arr1.length = 10;</span><br><span class="line"></span><br><span class="line">var arr2 = [10];</span><br><span class="line">// arr2[0] = 10;</span><br><span class="line">// arr.length = 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var arr3 = new Array(1,2,3);</span><br><span class="line">// [1,2,3]</span><br><span class="line"></span><br><span class="line">var arr4 = [1,2,3];</span><br><span class="line">// [1,2,3]</span><br><span class="line"></span><br><span class="line">// 看出区别了吗？</span><br></pre></td></tr></table></figure><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set拥有内置的构造函数，它不像Array一样可以简写为[]。</p><blockquote><p>Set([iterable])</p></blockquote><p>为了创建一个新的集合，我们需要使用新的语法，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var emptySet = new Set();</span><br><span class="line">var exampleSet = new Set([1,2,3]);</span><br><span class="line"></span><br><span class="line">// new Set(1); </span><br><span class="line">// 这种写法是绝对错误的</span><br></pre></td></tr></table></figure><p>Set接收数组作为其输入参数，并将分别创建set对象。但它只能包含该数组中的不同元素，也就是说不能重复。</p><p>当然，我们也可以使用Array.from()方法将一个集合转换为数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var set = new Set([1,2,3]); // &#123;1,2,3&#125;</span><br><span class="line"></span><br><span class="line">var arr = Array.from(set); // [1,2,3]</span><br></pre></td></tr></table></figure><p>好了，既然我们知道如何创建它们，那么如何实现它们的功能呢？现在我们将对Array/Set提供的基本方法进行一些比较：</p><h2 id="定位元素-访问元素"><a href="#定位元素-访问元素" class="headerlink" title="定位元素/访问元素"></a>定位元素/访问元素</h2><ul><li>首先，Set不支持像Array一样通过索引访问元素，这表示：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(set[0]); // undefined</span><br><span class="line">console.log(arr[0]); // 1</span><br></pre></td></tr></table></figure><ul><li><p>更重要的是，由于数组数据存储在连续的存储器中，因此CPU将能够对数据进行更快的读取。因此，如果与其他的抽象数据类型相比，迭代Array中的元素会更快，更高效。</p></li><li><p>Set.prototype.has 和 Array.prototype.indexOf</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">console.log(set.has(0)); // false</span><br><span class="line">console.log(arr.indexOf(0)); // -1</span><br><span class="line"></span><br><span class="line">console.log(set.has(1)); // true</span><br><span class="line">console.log(arr.indexOf(1)); // 0</span><br></pre></td></tr></table></figure><p>这里，arr要比set更麻烦些，因为你通常需要对arr做一次检查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var isExist = arr.indexOf(1) !== -1;</span><br></pre></td></tr></table></figure><p><strong>tip</strong>：ES6中有一个Array.prototype.includes()方法，它的作用类似于has()。</p><h2 id="插入-新增元素"><a href="#插入-新增元素" class="headerlink" title="插入/新增元素"></a>插入/新增元素</h2><p><strong>Array</strong>：</p><ul><li>Array.prototype.push()：将元素添加到数组的末尾；时间复杂度O(1)；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.push(4); // [1,2,3,4]</span><br></pre></td></tr></table></figure><ul><li>Array.prototype.unshift()：将元素添加到数组的开头；时间复杂度O(n)；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.unshift(3);</span><br><span class="line">arr.unshift(5,6);</span><br></pre></td></tr></table></figure><p><strong>Set</strong></p><ul><li>在Set中，只有一种方法可以添加新元素，Set.prototype.add()。由于Set必须使它的set成员保持“独一无二”的属性，所以在每次调用add()时，Set需要检查所有成员以确保在继续之前没有重复。通常，add()方法将耗费O(n)的运行时间，但由于使用了hash table的实现方法，实际上Set中的add()只需要时间O(1)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set.add(3); //&#123;1,2,3&#125; </span><br><span class="line">set.add(4); //&#123;1,2,3,4&#125;</span><br></pre></td></tr></table></figure><p>因此，这里Set在添加元素时与Array几乎相同。</p><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p><strong>Array</strong></p><p>使Array如此受欢迎的原因之一是它提供了许多不同的方法来删除元素，例如：</p><ul><li>Pop()：删除最后一个元素，时间复杂度为O(1)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3,4,5,6];</span><br><span class="line">arr.pop(); // return 6, [1,2,3,4,5]</span><br></pre></td></tr></table></figure><ul><li>Shift()：删除第一个元素，时间复杂度为O(n)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3,4,5,6];</span><br><span class="line">arr.shift(); // return 1, [2,3,4,5,6]</span><br></pre></td></tr></table></figure><ul><li>Splice(index, deleteCount)：删除从index到deleteCount区间的元素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3,4,5,6];</span><br><span class="line">arr.splice(0,2); // return [1,2], arr = [3,4,5,6]</span><br></pre></td></tr></table></figure><p><strong>Set</strong></p><p>与此同时，在Set里，我们会用：</p><ul><li>Delete(element)：删除一个Set中特定的元素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.delete(4) // &#123;1,2,3,5,6&#125;，4是元素，而不是索引</span><br></pre></td></tr></table></figure><ul><li>clear()：删除Set中的所有元素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.clear() // &#123;&#125;</span><br></pre></td></tr></table></figure><p>和Set相比，Array为我们提供了更多的原生功能（reduce()，reverse()，sort()等…），而Set目前只具有上面提到的基本功能。那么我们为什么会更喜欢Set呢？</p><h2 id="Set和Array的适用场合？"><a href="#Set和Array的适用场合？" class="headerlink" title="Set和Array的适用场合？"></a>Set和Array的适用场合？</h2><ul><li>首先，Set和Array是不同那个的，它诞生的目的并不是要取代Array，而是为了弥补Array的不足。由于Set只包含不同的元素，也就是说，它拥有一项自动去重的功能，这会在一定程度上减轻我们的工作。</li><li>Set又叫集合，和我们在数学课里学到的集合是同一个概念，它提供了内置的交集（intersect），并集（union）和差集（difference）等方法。</li><li>数组适用于这种情况：我们希望保持元素的排序以便于快速访问，或者进行大量修改（删除或新增元素），或者任何需要对元素进行直接的索引访问的操作场景。</li></ul><p>总而言之，我认为Set的关键点在于“不同”，以及需要整合不同的数据集的时候，它才是更加高效的。在此情况之外，Array通常是更好的选择。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Set和Array是什么？&quot;&gt;&lt;a href=&quot;#Set和Array是什么？&quot; class=&quot;headerlink&quot; title=&quot;Set和Array是什么？&quot;&gt;&lt;/a&gt;Set和Array是什么？&lt;/h2&gt;&lt;p&gt;绝不会有任何一个前端开发者会告诉你说他不熟悉数组(Array)，我们每天都会无数次的和数组打交道，但到底数组是什么呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数组对象是使用单独的变量名在内存中存储的一系列的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如：&lt;code&gt;[1,2,3,1]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;那什么是set呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Set是一种抽象数据类型，只包含不同的元素/对象，而不需要按索引顺序分配&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如：&lt;code&gt;{1，2，3}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;根据定义，Array和Set在技术上是两种不同的概念。&lt;/p&gt;
    
    </summary>
    
      <category term="Web开发" scheme="http://zyqvizzz.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="ECMAScript 6" scheme="http://zyqvizzz.github.io/tags/ECMAScript-6/"/>
    
      <category term="JavaScript" scheme="http://zyqvizzz.github.io/tags/JavaScript/"/>
    
      <category term="数据结构" scheme="http://zyqvizzz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Node.js学习：使用loopback做邮箱验证</title>
    <link href="http://zyqvizzz.github.io/Node.js%E5%AD%A6%E4%B9%A0%EF%BC%9A%E4%BD%BF%E7%94%A8loopback%E5%81%9A%E9%82%AE%E7%AE%B1%E9%AA%8C%E8%AF%81/"/>
    <id>http://zyqvizzz.github.io/Node.js学习：使用loopback做邮箱验证/</id>
    <published>2017-07-01T09:52:57.000Z</published>
    <updated>2018-08-14T07:11:16.582Z</updated>
    
    <content type="html"><![CDATA[<h2 id="注册用户"><a href="#注册用户" class="headerlink" title="注册用户"></a>注册用户</h2><p>LoopBack用户模型提供了注册新用户并确认其电子邮件地址的方法。您还可以使用loopback-component-passport模块将登录信息与Facebook，Google和其他第三方提供商集成。</p><a id="more"></a><h3 id="使用LoopBack用户模型注册用户"><a href="#使用LoopBack用户模型注册用户" class="headerlink" title="使用LoopBack用户模型注册用户"></a>使用LoopBack用户模型注册用户</h3><h4 id="创建新用户"><a href="#创建新用户" class="headerlink" title="创建新用户"></a>创建新用户</h4><p>a. 通过添加模型实例创建用户（注册用户），电子邮件和密码是唯一必需的属性。</p><p><strong>/server/boot/my-boot-script.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(app) &#123;</span><br><span class="line">  var User = app.models.User;</span><br><span class="line">  User.create(&#123;email: &apos;foo@bar.com&apos;, password: &apos;bar&apos;&#125;, function(err, userInstance) &#123;</span><br><span class="line">    console.log(userInstance);</span><br><span class="line">  &#125;);</span><br><span class="line">  //...</span><br></pre></td></tr></table></figure><blockquote><p>注：如果/boot文件夹中没有这个js文件，可以自己新建一个<code>my-boot-script.js</code>。这个文件夹中脚本的作用是执行一些初始化的设置。默认情况下，运行引导脚本后，应用程序在启动时会自动执行该文件夹中的脚本。</p></blockquote><p>b. 使用POST /users接口创建一个新的用户实例，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -H &quot;Content-Type:application/json&quot;         \</span><br><span class="line">-d &apos;&#123;&quot;email&quot;: &quot;me@domain.com&quot;, &quot;password&quot;: &quot;secret&quot;&#125;&apos;   \</span><br><span class="line">http://localhost:3000/api/users</span><br></pre></td></tr></table></figure><h4 id="添加其他注册限制"><a href="#添加其他注册限制" class="headerlink" title="添加其他注册限制"></a>添加其他注册限制</h4><p>我们可能会在注册过程中添加方法，比如查看给定的用户名是否可用，或者是否已经注册了一个电子邮件地址。通常做法是在User对象上添加一个beforeRemote方法。</p><h4 id="验证电子邮件地址"><a href="#验证电子邮件地址" class="headerlink" title="验证电子邮件地址"></a>验证电子邮件地址</h4><p>通常，应用程序将要求用户在登录之前验证其电子邮件地址。所以我们需要向用户发送一封包含链接的电子邮件，来验证其地址。一旦用户点击链接，他们就会被重定向到网站的登录页面（“/”），并且将能够正常登录。</p><p>如果需要强制验证注册，请在server/model-config.json中将emailVerificationRequired用户模型属性设置为true;</p><p><strong>server/model-config.json</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&quot;user&quot;: &#123;</span><br><span class="line">    &quot;dataSource&quot;: &quot;db&quot;,</span><br><span class="line">    &quot;public&quot;: true,</span><br><span class="line">    &quot;options&quot;: &#123;</span><br><span class="line">      &quot;emailVerificationRequired&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通过REST，使用<code>GET /users/confirm</code>接口来验证用户的电子邮件地址。</p><p>此示例在User模型上创建了一个远程钩子，并在create()方法被调用之后执行。</p><p><strong>/common/models/user.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> config = <span class="built_in">require</span>(<span class="string">'../../server/config.json'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//send verification email after registration</span></span><br><span class="line">  user.afterRemote(<span class="string">'create'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">context, userInstance, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'&gt; user.afterRemote triggered'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> options = &#123;</span><br><span class="line">      type: <span class="string">'email'</span>,</span><br><span class="line">      to: userInstance.email,</span><br><span class="line">      <span class="keyword">from</span>: <span class="string">'noreply@loopback.com'</span>,</span><br><span class="line">      subject: <span class="string">'Thanks for registering.'</span>,</span><br><span class="line">      template: path.resolve(__dirname, <span class="string">'../../server/views/verify.ejs'</span>),</span><br><span class="line">      redirect: <span class="string">'/verified'</span>,</span><br><span class="line">      user: user</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    userInstance.verify(options, <span class="function"><span class="keyword">function</span>(<span class="params">err, response, next</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> next(err);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'&gt; verification email sent:'</span>, response);</span><br><span class="line"></span><br><span class="line">      context.res.render(<span class="string">'response'</span>, &#123;</span><br><span class="line">        title: <span class="string">'Signed up successfully'</span>,</span><br><span class="line">        content: <span class="string">'Please check your email and click on the verification link '</span> -</span><br><span class="line">            <span class="string">'before logging in.'</span>,</span><br><span class="line">        redirectTo: <span class="string">'/'</span>,</span><br><span class="line">        redirectToLinkText: <span class="string">'Log in'</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>有关完整的示例，请参阅<a href="https://github.com/strongloop/loopback-example-user-management" target="_blank" rel="noopener">loopback-example-user-management</a>中的user.js。</p><p>接下来，我们将以<code>loopback-example-user-management</code>为例，详细地完成验证邮箱的过程。</p><p>首先需要在<code>/server/model-config.json</code>里配置邮件数据源。</p><p><strong>/server/model-config.json</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// ···</span><br><span class="line">&quot;Role&quot;: &#123;</span><br><span class="line">  &quot;dataSource&quot;: &quot;db&quot;,</span><br><span class="line">  &quot;public&quot;: false</span><br><span class="line">&#125;,</span><br><span class="line">&quot;Email&quot;: &#123;</span><br><span class="line">  &quot;dataSource&quot;: &quot;emailDs&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;user&quot;: &#123;</span><br><span class="line">  &quot;dataSource&quot;: &quot;db&quot;,</span><br><span class="line">  &quot;public&quot;: true,</span><br><span class="line">  &quot;options&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>接下来配置<code>/server/datasources.json</code>文件，即配置邮件数据源，示例项目中的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&quot;emailDs&quot;: &#123;</span><br><span class="line">  &quot;name&quot;: &quot;emailDs&quot;,</span><br><span class="line">  &quot;connector&quot;: &quot;mail&quot;,</span><br><span class="line">  &quot;transports&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;smtp&quot;,</span><br><span class="line">      &quot;host&quot;: &quot;smtp.gmail.com&quot;,</span><br><span class="line">      &quot;secure&quot;: true,</span><br><span class="line">      &quot;port&quot;: 465,</span><br><span class="line">      &quot;tls&quot;: &#123;</span><br><span class="line">        &quot;rejectUnauthorized&quot;: false</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;auth&quot;: &#123;</span><br><span class="line">        &quot;user&quot;: &quot;email@address.com&quot;,</span><br><span class="line">        &quot;pass&quot;: &quot;password&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要改两个地方，一个是host要改成你指定的源地址，如果是gmail邮箱，就写成smtp.gmail.com，如果是qq邮箱，就改成smtp.qq.com。另外一个改动是auth中的user和pass，这里写的是用于发送邮件的邮箱的邮箱名和密码，也就是设置用这个邮箱给注册的用户邮箱发送邮件。</p><p>现在运行项目，打开<a href="http://localhost:3000/explorer" target="_blank" rel="noopener">http://localhost:3000/explorer</a>，我们现在在API explorer中注册一个用户。</p><p><img src="http://upload-images.jianshu.io/upload_images/3396508-a0c383cf1f8ae6f6.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="http://upload-images.jianshu.io/upload_images/3396508-21f7a85f0a4f6835.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>它将返回一个提示网页，这表示验证邮件已经成功发到了注册的邮箱中。</p><p>打开邮箱，激活链接，再次登录即可成功。</p><p><img src="http://upload-images.jianshu.io/upload_images/3396508-2a79dad4442a12a8.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>现在回到explorer，使用登录接口。</p><p><img src="http://upload-images.jianshu.io/upload_images/3396508-f66320234c58e36e.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="http://upload-images.jianshu.io/upload_images/3396508-30fee2b86137cf76.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>返回的参数中，id为返回的token，ttl为token默认的有效周期，可以手动修改。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;注册用户&quot;&gt;&lt;a href=&quot;#注册用户&quot; class=&quot;headerlink&quot; title=&quot;注册用户&quot;&gt;&lt;/a&gt;注册用户&lt;/h2&gt;&lt;p&gt;LoopBack用户模型提供了注册新用户并确认其电子邮件地址的方法。您还可以使用loopback-component-passport模块将登录信息与Facebook，Google和其他第三方提供商集成。&lt;/p&gt;
    
    </summary>
    
      <category term="Web开发" scheme="http://zyqvizzz.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Node.JS" scheme="http://zyqvizzz.github.io/tags/Node-JS/"/>
    
      <category term="LoopBack" scheme="http://zyqvizzz.github.io/tags/LoopBack/"/>
    
  </entry>
  
  <entry>
    <title>Node.js学习：使用Loopback3.0构建应用程序（二）</title>
    <link href="http://zyqvizzz.github.io/Node.js%E5%AD%A6%E4%B9%A0%EF%BC%9A%E4%BD%BF%E7%94%A8Loopback3.0%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://zyqvizzz.github.io/Node.js学习：使用Loopback3.0构建应用程序（二）/</id>
    <published>2017-06-23T10:12:57.000Z</published>
    <updated>2018-08-14T07:11:16.574Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、咖啡店点评应用"><a href="#一、咖啡店点评应用" class="headerlink" title="一、咖啡店点评应用"></a>一、咖啡店点评应用</h2><h3 id="应用概述"><a href="#应用概述" class="headerlink" title="应用概述"></a>应用概述</h3><p>咖啡店点评是一个网站，您可以用来发布咖啡店的评论。</p><p><img src="http://upload-images.jianshu.io/upload_images/3396508-8162aa3006d9d9bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这个应用程序用到了两个不同的数据源：它会将评论者数据存储在MySQL数据库中，并把咖啡店和评论数据存储在MongoDB数据库中。</p><a id="more"></a><p>这个应用有三个数据模型：</p><ul><li>CoffeeShop（这个模型我们已经在上一步中定义好了）</li><li>Review</li><li>Reviewer</li></ul><p>它们有如下关系：</p><ul><li>一个CoffeeShop拥有多个review</li><li>一个CoffeeShop拥有多个reviewer</li><li>一个review属于一个CoffeeShop</li><li>一个review属于一个reviewer</li><li>一个reviewer拥有多个review</li></ul><p>一般来说，用户可以创建，编辑，删除和阅读咖啡店的评论，并通过ACLs指定基本规则和权限：</p><ul><li>任何人都可以阅读评论，但必须先登录才能创建，编辑或删除它们。</li><li>任何人都可以注册为用户，然后能够登录或者注销。</li><li>登录用户可以创建新的评论，编辑或删除自己的评论，但是他们不能修改一开始选择的咖啡店。</li></ul><h2 id="二、创建新的数据源"><a href="#二、创建新的数据源" class="headerlink" title="二、创建新的数据源"></a>二、创建新的数据源</h2><h3 id="添加一个新的数据源"><a href="#添加一个新的数据源" class="headerlink" title="添加一个新的数据源"></a>添加一个新的数据源</h3><p>除了将API连接到上一步创建的MySQL数据源之外，现在还需要添加一个MongoDB数据源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lb datasource</span><br></pre></td></tr></table></figure><p>出现提示时，回复如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? Enter the data-source name: mongoDs</span><br><span class="line">? Select the connector for mongoDs: MongoDB (supported by StrongLoop)</span><br></pre></td></tr></table></figure><p>接下来输入一些数据源设置，如主机，端口，用户，密码和数据库名称，然后安装数据库连接器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">? Enter the datasource name: mongodb</span><br><span class="line">? Select the connector for mongodb: MongoDB (supported by StrongLoop)</span><br><span class="line">? Connection String url to override other settings (eg: mongodb://username:password@hostname:port/database):</span><br><span class="line">? host: localhost</span><br><span class="line">? port: 27017</span><br><span class="line">? user: demo</span><br><span class="line">? password: ****</span><br><span class="line">? database: demo</span><br><span class="line">? Install loopback-connector-mongodb@^1.4 Yes</span><br></pre></td></tr></table></figure><p>数据库连接器可以使用npm自行安装，数据源设置也可以手动添加到<code>server/ datasources.json</code>中。</p><p>安装MongoDB连接器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save loopback-connector-mongodb</span><br></pre></td></tr></table></figure><h3 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h3><p>在<code>server/datasources.json</code>中配置新的数据源。</p><p><strong>server/datasources.json</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&quot;mongoDs&quot;: &#123;</span><br><span class="line">  &quot;name&quot;: &quot;mongoDs&quot;,</span><br><span class="line">  &quot;connector&quot;: &quot;mongodb&quot;,</span><br><span class="line">  &quot;host&quot;: &quot;demo.strongloop.com&quot;,</span><br><span class="line">  &quot;port&quot;: 27017,</span><br><span class="line">  &quot;database&quot;: &quot;getting_started_intermediate&quot;,</span><br><span class="line">  &quot;username&quot;: &quot;demo&quot;,</span><br><span class="line">  &quot;password&quot;: &quot;L00pBack&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、添加新的数据模型"><a href="#三、添加新的数据模型" class="headerlink" title="三、添加新的数据模型"></a>三、添加新的数据模型</h2><h3 id="定义Review数据模型"><a href="#定义Review数据模型" class="headerlink" title="定义Review数据模型"></a>定义Review数据模型</h3><p>输入：</p><figure class="highlight plain"><figcaption><span>model```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">出现提示时，输入或选择以下内容：</span><br><span class="line"></span><br><span class="line">* Model name：Review</span><br><span class="line">* Data source: mongoDs (mongodb)</span><br><span class="line">* Base class: Use the down-arrow key to select PersistedModel.</span><br><span class="line">* Expose Reviewer via the REST API? Press RETURN to accept the default, Yes.</span><br><span class="line">* Custom plural form (used to build REST URL):  Press RETURN to accept the default, Yes.</span><br><span class="line">* Common model or server only: Press RETURN to accept the default, common model.</span><br><span class="line"></span><br><span class="line">然后根据提示加入以下属性。</span><br><span class="line"></span><br><span class="line">&lt;table&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;th&gt;Property name&lt;/th&gt;</span><br><span class="line">&lt;th&gt;Property type&lt;/th&gt;</span><br><span class="line">&lt;th&gt;Required?&lt;/th&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt; date &lt;/td&gt;</span><br><span class="line">&lt;td&gt; date &lt;/td&gt;</span><br><span class="line">&lt;td&gt; y &lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt; rating &lt;/td&gt;</span><br><span class="line">&lt;td&gt; number &lt;/td&gt;</span><br><span class="line">&lt;td&gt; n &lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt; comments &lt;/td&gt;</span><br><span class="line">&lt;td&gt; string &lt;/td&gt;</span><br><span class="line">&lt;td&gt; y &lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line"></span><br><span class="line">### 定义Reviewer数据模型</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line"></span><br><span class="line">```lb model</span><br></pre></td></tr></table></figure><p>出现提示时，输入或选择以下内容：</p><ul><li><strong>Model name</strong>: Reviewer</li><li><strong>Data source</strong>: mongoDs (mongodb)</li><li><strong>Base class</strong>: 选择User.</li><li><strong>Expose Reviewer via the REST API?</strong>: 选择默认选项，yes</li><li><strong>Custom plural form (used to build REST URL)</strong>: 选择默认选项，yes</li></ul><p>接下来不需要给Reviewer添加任何属性，它们都是从基本的用户模型继承下来的。</p><h3 id="更新启动脚本，添加一些原始数据"><a href="#更新启动脚本，添加一些原始数据" class="headerlink" title="更新启动脚本，添加一些原始数据"></a>更新启动脚本，添加一些原始数据</h3><p>在启动脚本<code>server/boot/create-sample-models.js</code>中添加一些代码，这个启动脚本有如下几个功能：</p><ul><li>createCoffeeShops()为CoffeeShop模型创建一个MySQL表，并将数据添加到表中。</li><li>createReviewers()使用自动迁移在MongoDB中创建Reviewer数据结构，并向其添加数据。</li><li>createReviews()使用自动迁移在MongoDB中创建评论数据结构，并向其添加数据。</li></ul><p><strong>server/boot/create-sample-models.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">var async = require(&apos;async&apos;);</span><br><span class="line">module.exports = function(app) &#123;</span><br><span class="line">  //data sources</span><br><span class="line">  var mongoDs = app.dataSources.mongoDs; // &apos;name&apos; of your mongo connector, you can find it in datasource.json</span><br><span class="line">  var mysqlDs = app.dataSources.mysqlDs;</span><br><span class="line">  //create all models</span><br><span class="line">  async.parallel(&#123;</span><br><span class="line">    reviewers: async.apply(createReviewers),</span><br><span class="line">    coffeeShops: async.apply(createCoffeeShops),</span><br><span class="line">  &#125;, function(err, results) &#123;</span><br><span class="line">    if (err) throw err;</span><br><span class="line">    createReviews(results.reviewers, results.coffeeShops, function(err) &#123;</span><br><span class="line">      console.log(&apos;&gt; models created sucessfully&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  //create reviewers</span><br><span class="line">  function createReviewers(cb) &#123;</span><br><span class="line">    mongoDs.automigrate(&apos;Reviewer&apos;, function(err) &#123;</span><br><span class="line">      if (err) return cb(err);</span><br><span class="line">      var Reviewer = app.models.Reviewer;</span><br><span class="line">      Reviewer.create([&#123;</span><br><span class="line">        email: &apos;foo@bar.com&apos;,</span><br><span class="line">        password: &apos;foobar&apos;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        email: &apos;john@doe.com&apos;,</span><br><span class="line">        password: &apos;johndoe&apos;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        email: &apos;jane@doe.com&apos;,</span><br><span class="line">        password: &apos;janedoe&apos;</span><br><span class="line">      &#125;], cb);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  //create coffee shops</span><br><span class="line">  function createCoffeeShops(cb) &#123;</span><br><span class="line">    mysqlDs.automigrate(&apos;CoffeeShop&apos;, function(err) &#123;</span><br><span class="line">      if (err) return cb(err);</span><br><span class="line">      var CoffeeShop = app.models.CoffeeShop;</span><br><span class="line">      CoffeeShop.create([&#123;</span><br><span class="line">        name: &apos;Bel Cafe&apos;,</span><br><span class="line">        city: &apos;Vancouver&apos;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        name: &apos;Three Bees Coffee House&apos;,</span><br><span class="line">        city: &apos;San Mateo&apos;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        name: &apos;Caffe Artigiano&apos;,</span><br><span class="line">        city: &apos;Vancouver&apos;</span><br><span class="line">      &#125;, ], cb);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  //create reviews</span><br><span class="line">  function createReviews(reviewers, coffeeShops, cb) &#123;</span><br><span class="line">    mongoDs.automigrate(&apos;Review&apos;, function(err) &#123;</span><br><span class="line">      if (err) return cb(err);</span><br><span class="line">      var Review = app.models.Review;</span><br><span class="line">      var DAY_IN_MILLISECONDS = 1000 * 60 * 60 * 24;</span><br><span class="line">      Review.create([&#123;</span><br><span class="line">        date: Date.now() - (DAY_IN_MILLISECONDS * 4),</span><br><span class="line">        rating: 5,</span><br><span class="line">        comments: &apos;A very good coffee shop.&apos;,</span><br><span class="line">        publisherId: reviewers[0].id,</span><br><span class="line">        coffeeShopId: coffeeShops[0].id,</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        date: Date.now() - (DAY_IN_MILLISECONDS * 3),</span><br><span class="line">        rating: 5,</span><br><span class="line">        comments: &apos;Quite pleasant.&apos;,</span><br><span class="line">        publisherId: reviewers[1].id,</span><br><span class="line">        coffeeShopId: coffeeShops[0].id,</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        date: Date.now() - (DAY_IN_MILLISECONDS * 2),</span><br><span class="line">        rating: 4,</span><br><span class="line">        comments: &apos;It was ok.&apos;,</span><br><span class="line">        publisherId: reviewers[1].id,</span><br><span class="line">        coffeeShopId: coffeeShops[1].id,</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        date: Date.now() - (DAY_IN_MILLISECONDS),</span><br><span class="line">        rating: 4,</span><br><span class="line">        comments: &apos;I go here everyday.&apos;,</span><br><span class="line">        publisherId: reviewers[2].id,</span><br><span class="line">        coffeeShopId: coffeeShops[2].id,</span><br><span class="line">      &#125;], cb);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="四、定义模型的关系"><a href="#四、定义模型的关系" class="headerlink" title="四、定义模型的关系"></a>四、定义模型的关系</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>LoopBack支持许多不同类型的模型关系：BelongsTo, HasMany, HasManyThrough, and HasAndBelongsToMany等等。</p><p>在“咖啡店评论”应用程序中，有以下几种关系：</p><ul><li>一个CoffeeShop拥有多个review</li><li>一个CoffeeShop拥有多个reviewer</li><li>一个review属于一个CoffeeShop</li><li>一个review属于一个reviewer</li><li>一个reviewer拥有多个review</li></ul><h3 id="定义关系"><a href="#定义关系" class="headerlink" title="定义关系"></a>定义关系</h3><p>现在，我们将使用<code>lb relation</code>来定义这些模型之间的关系。</p><p><strong>一个CoffeeShop拥有多个review</strong>，没有中间模型和外键。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">? Select the model to create the relationship from: CoffeeShop</span><br><span class="line">? Relation type: has many</span><br><span class="line">? Choose a model to create a relationship with: Review</span><br><span class="line">? Enter the property name for the relation: reviews</span><br><span class="line">? Optionally enter a custom foreign key:</span><br><span class="line">? Require a through model? No</span><br></pre></td></tr></table></figure><p><strong>一个CoffeeShop拥有多个reviewer</strong>，没有中间模型和外键</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">? Select the model to create the relationship from: CoffeeShop</span><br><span class="line">? Relation type: has many</span><br><span class="line">? Choose a model to create a relationship with: Reviewer</span><br><span class="line">? Enter the property name for the relation: reviewers</span><br><span class="line">? Optionally enter a custom foreign key:</span><br><span class="line">? Require a through model? No</span><br></pre></td></tr></table></figure><p><strong>一个review属于一个CoffeeShop</strong>，没有外键。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">? Select the model to create the relationship from: CoffeeShop</span><br><span class="line">? Relation type: has many</span><br><span class="line">? Choose a model to create a relationship with: Reviewer</span><br><span class="line">? Enter the property name for the relation: reviewers</span><br><span class="line">? Optionally enter a custom foreign key:</span><br><span class="line">? Require a through model? No</span><br></pre></td></tr></table></figure><p><strong>一个review属于一个reviewer</strong>，外键是<code>publisherId</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? Select the model to create the relationship from: Review</span><br><span class="line">? Relation type: belongs to</span><br><span class="line">? Choose a model to create a relationship with: Reviewer</span><br><span class="line">? Enter the property name for the relation: reviewer</span><br><span class="line">? Optionally enter a custom foreign key: publisherId</span><br></pre></td></tr></table></figure><p><strong>一个reviewer拥有多个review</strong>，外键是<code>publisherId</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">? Select the model to create the relationship from: Reviewer</span><br><span class="line">? Relation type: has many</span><br><span class="line">? Choose a model to create a relationship with: Review</span><br><span class="line">? Enter the property name for the relation: reviews</span><br><span class="line">? Optionally enter a custom foreign key: publisherId</span><br><span class="line">? Require a through model? No</span><br></pre></td></tr></table></figure><h3 id="查看JSON模型文件"><a href="#查看JSON模型文件" class="headerlink" title="查看JSON模型文件"></a>查看JSON模型文件</h3><p>现在，查看<code>common/models/review.json</code>。你应该会看到这些：</p><p><strong>common/models/review.json</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&quot;relations&quot;: &#123;</span><br><span class="line">  &quot;coffeeShop&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;belongsTo&quot;,</span><br><span class="line">    &quot;model&quot;: &quot;CoffeeShop&quot;,</span><br><span class="line">    &quot;foreignKey&quot;: &quot;&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;reviewer&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;belongsTo&quot;,</span><br><span class="line">    &quot;model&quot;: &quot;Reviewer&quot;,</span><br><span class="line">    &quot;foreignKey&quot;: &quot;publisherId&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>同样，其他的json文件中应该有如下代码：</p><p><strong>common/models/reviewer.json</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&quot;relations&quot;: &#123;</span><br><span class="line">  &quot;reviews&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;hasMany&quot;,</span><br><span class="line">    &quot;model&quot;: &quot;Review&quot;,</span><br><span class="line">    &quot;foreignKey&quot;: &quot;publisherId&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>common/models/coffee-shop.json</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&quot;relations&quot;: &#123;</span><br><span class="line">  &quot;reviews&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;hasMany&quot;,</span><br><span class="line">    &quot;model&quot;: &quot;Review&quot;,</span><br><span class="line">    &quot;foreignKey&quot;: &quot;&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;reviewers&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;hasMany&quot;,</span><br><span class="line">    &quot;model&quot;: &quot;Reviewer&quot;,</span><br><span class="line">    &quot;foreignKey&quot;: &quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="五、定义权限控制"><a href="#五、定义权限控制" class="headerlink" title="五、定义权限控制"></a>五、定义权限控制</h2><h3 id="权限控制简介"><a href="#权限控制简介" class="headerlink" title="权限控制简介"></a>权限控制简介</h3><p>loopback应用通过模型访问数据，因此控制对数据的访问意味着对模型进行权限的控制：也就是说，指定什么角色可以在模型上执行读取和写入数据的方法。loopback权限控制由权限控制列表或ACL决定。</p><p>接下来，我们将为Review模型设置权限控制。</p><p>权限控制应执行以下规则：</p><ul><li>任何人都可以阅读评论。但是创建、编辑和删除的操作必须在登录之后才有权限。</li><li>任何人都可以注册为用户，可以登录和登出。</li><li>登录用户可以创建新的评论，编辑或删除自己的评论。然而，他们不能修改咖啡店的评论。</li></ul><h3 id="定义权限控制"><a href="#定义权限控制" class="headerlink" title="定义权限控制"></a>定义权限控制</h3><p>这次我们使用lb的acl子命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lb acl</span><br></pre></td></tr></table></figure><p>首先，<strong>拒绝所有人操作所有接口</strong>，这通常是定义ACL的起点，因为您可以选择性地允许特定操作的访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? Select the model to apply the ACL entry to: (all existing models)</span><br><span class="line">? Select the ACL scope: All methods and properties</span><br><span class="line">? Select the access type: All (match all types)</span><br><span class="line">? Select the role: All users</span><br><span class="line">? Select the permission to apply: Explicitly deny access</span><br></pre></td></tr></table></figure><p><strong>现在允许所有人对reviews进行读操作</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? Select the model to apply the ACL entry to: Review</span><br><span class="line">? Select the ACL scope: All methods and properties</span><br><span class="line">? Select the access type: Read</span><br><span class="line">? Select the role: All users</span><br><span class="line">? Select the permission to apply: Explicitly grant access</span><br></pre></td></tr></table></figure><p><strong>允许通过身份验证的用户对coffeeshops进行读操作</strong>，也就是说，已登录的用户可以浏览所有咖啡店。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? Select the model to apply the ACL entry to: CoffeeShop</span><br><span class="line">? Select the ACL scope: All methods and properties</span><br><span class="line">? Select the access type: Read</span><br><span class="line">? Select the role: Any authenticated user</span><br><span class="line">? Select the permission to apply: Explicitly grant access</span><br></pre></td></tr></table></figure><p><strong>允许经过身份验证的用户对reviews进行写操作</strong>，也就是说，已登录的用户可以添加一条评论。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? Select the model to apply the ACL entry to: Review</span><br><span class="line">? Select the ACL scope: A single method</span><br><span class="line">? Enter the method name: create</span><br><span class="line">? Select the role: Any authenticated user</span><br><span class="line">? Select the permission to apply: Explicitly grant access</span><br></pre></td></tr></table></figure><p><strong>使review的作者有权限（其“所有者”）对其进行任何更改</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ lb acl</span><br><span class="line">? Select the model to apply the ACL entry to: Review</span><br><span class="line">? Select the ACL scope: All methods and properties</span><br><span class="line">? Select the access type: Write</span><br><span class="line">? Select the role: The user owning the object</span><br><span class="line">? Select the permission to apply: Explicitly grant access</span><br></pre></td></tr></table></figure><h3 id="查看review-json文件"><a href="#查看review-json文件" class="headerlink" title="查看review.json文件"></a>查看review.json文件</h3><p>完成上述步骤，此时的<code>common/models/review.json</code>中的ACL部分应如下所示：</p><h2 id="六、定义一个远程钩子"><a href="#六、定义一个远程钩子" class="headerlink" title="六、定义一个远程钩子"></a>六、定义一个远程钩子</h2><h3 id="远程钩子介绍"><a href="#远程钩子介绍" class="headerlink" title="远程钩子介绍"></a>远程钩子介绍</h3><p>远程钩子（remote hook）是一个在远程方法（自定义远程方法或内置CRUD方法）之前或之后执行的功能。</p><p>在这个例子中，我们将定义一个远程钩子，每当在Review模型上调用create()方法时（在创建新的评论时），它将被调用。</p><p>您可以定义两种远程钩子：</p><ul><li><code>beforeRemote()</code>在远程方法之前运行。</li><li><code>afterRemote()</code>在远程方法之后运行。</li></ul><p>在这两种情况下，有两个参数可以供我们使用：一个与要钩子函数的远程方法匹配的字符串，和一个回调函数。</p><h3 id="创建一个远程钩子"><a href="#创建一个远程钩子" class="headerlink" title="创建一个远程钩子"></a>创建一个远程钩子</h3><p>这里，您将在review模型中定义一个远程钩子，具体来说是<code>Review.beforeRemote</code>。</p><p>修改<code>common/models/review.js</code>，并添加以下代码：</p><p><strong>common/models/review.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(Review) &#123;</span><br><span class="line">  Review.beforeRemote(&apos;create&apos;, function(context, user, next) &#123;</span><br><span class="line">    context.args.data.date = Date.now();</span><br><span class="line">    context.args.data.publisherId = context.req.accessToken.userId;</span><br><span class="line">    next();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在创建Review模型的新实例之前调用此函数。The code:</p><ul><li>设置publisherId为请求中的userId</li><li>设置日期为当前日期。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、咖啡店点评应用&quot;&gt;&lt;a href=&quot;#一、咖啡店点评应用&quot; class=&quot;headerlink&quot; title=&quot;一、咖啡店点评应用&quot;&gt;&lt;/a&gt;一、咖啡店点评应用&lt;/h2&gt;&lt;h3 id=&quot;应用概述&quot;&gt;&lt;a href=&quot;#应用概述&quot; class=&quot;headerlink&quot; title=&quot;应用概述&quot;&gt;&lt;/a&gt;应用概述&lt;/h3&gt;&lt;p&gt;咖啡店点评是一个网站，您可以用来发布咖啡店的评论。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3396508-8162aa3006d9d9bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个应用程序用到了两个不同的数据源：它会将评论者数据存储在MySQL数据库中，并把咖啡店和评论数据存储在MongoDB数据库中。&lt;/p&gt;
    
    </summary>
    
      <category term="Web开发" scheme="http://zyqvizzz.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Node.JS" scheme="http://zyqvizzz.github.io/tags/Node-JS/"/>
    
      <category term="LoopBack" scheme="http://zyqvizzz.github.io/tags/LoopBack/"/>
    
  </entry>
  
  <entry>
    <title>Node.js学习：使用Loopback3.0构建应用程序（一）</title>
    <link href="http://zyqvizzz.github.io/Node.js%E5%AD%A6%E4%B9%A0%EF%BC%9A%E4%BD%BF%E7%94%A8Loopback3.0%E6%9E%84%E5%BB%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://zyqvizzz.github.io/Node.js学习：使用Loopback3.0构建应用程序（一）/</id>
    <published>2017-06-20T14:12:57.000Z</published>
    <updated>2018-08-14T07:11:16.585Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><blockquote><p>安装LoopBack工具来创建和开发LoopBack 3.0应用程序。</p></blockquote><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p><a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">node下载地址</a></p><h3 id="安装loopback工具"><a href="#安装loopback工具" class="headerlink" title="安装loopback工具"></a>安装loopback工具</h3><p>虽然你可以自己从头开始编写一个LoopBack应用程序，但是安装一个LoopBack CLI工具能够使它更容易入门。它将构建应用程序的基本结构，然后您可以根据需要进行自定义。</p><p>LoopBack提供了两个工具的选项：<a href="http://loopback.io/doc/en/lb3/Installation.html#install-loopback-cli-tool" target="_blank" rel="noopener">LoopBack CLI</a> 和 <a href="http://loopback.io/doc/en/lb3/Installation.html#install-ibm-api-connect-developer-toolkit" target="_blank" rel="noopener">IBM API Connect开发工具包</a>，这里可以选择LoopBack CLI来进行应用程序的构建。</p><a id="more"></a><h4 id="安装Loopback-CLI工具"><a href="#安装Loopback-CLI工具" class="headerlink" title="安装Loopback CLI工具"></a>安装Loopback CLI工具</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g loopback-cli</span><br></pre></td></tr></table></figure><p>这一步将安装 <code>lb</code> 命令行工具，用于构建和修改LoopBack应用程序。</p><h3 id="安装更新"><a href="#安装更新" class="headerlink" title="安装更新"></a>安装更新</h3><p>如果之前安装过strongloop，需要进行一次版本的更新:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g strongloop</span><br></pre></td></tr></table></figure><p>如果遇到任何问题，可以尝试卸载重装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall -g strongloop</span><br><span class="line">npm cache clear</span><br><span class="line">npm install -g strongloop</span><br></pre></td></tr></table></figure><h2 id="二、使用Loopback创建一个应用"><a href="#二、使用Loopback创建一个应用" class="headerlink" title="二、使用Loopback创建一个应用"></a>二、使用Loopback创建一个应用</h2><h3 id="创建一个简单的API"><a href="#创建一个简单的API" class="headerlink" title="创建一个简单的API"></a>创建一个简单的API</h3><p>首先使用loopback-cli创建一个新的应用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lb</span><br></pre></td></tr></table></figure><p>LoopBack应用生成器将提示您输入应用程序的名称。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">     _-----_</span><br><span class="line">    |       |    .--------------------------.</span><br><span class="line">    |--(o)--|    |  Let&apos;s create a LoopBack |</span><br><span class="line">   `---------´   |       application!       |</span><br><span class="line">    ( _´U`_ )    &apos;--------------------------&apos;</span><br><span class="line">    /___A___\</span><br><span class="line">     |  ~  |</span><br><span class="line">   __&apos;.___.&apos;__</span><br><span class="line"> ´   `  |° ´ Y `</span><br><span class="line">[?] What&apos;s the name of your application? loopback-getting-started</span><br><span class="line">[?] Enter name of the directory to contain the project: loopback-getting-started</span><br></pre></td></tr></table></figure><blockquote><p>这里可以替换成任何你喜欢的名字，本教程使用了官方文档中的名称：loopback-getting-started。</p></blockquote><p>接下来cli工具会询问要创建什么样的应用程序：可以选择 <code>hello-world</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">? What kind of application do you have in mind? (Use arrow keys)</span><br><span class="line">  api-server (A LoopBack API server with local User auth)</span><br><span class="line">  empty-server (An empty LoopBack API, without any configured models or datasources)</span><br><span class="line">❯ hello-world (A project containing a controller, including a single vanilla Message and</span><br><span class="line">    a single remote method)</span><br><span class="line">  notes (A project containing a basic working example, including a memory database)</span><br></pre></td></tr></table></figure><p>然后，生成器将在其构建应用程序时创建如下信息，包括：</p><ol><li>初始化项目的文件夹结构。</li><li>创建默认的JSON文件。</li><li>创建默认的JavaScript文件。</li><li>下载并安装依赖节点模块（省去手动安装npm的一步）。</li></ol><h3 id="创建一个数据模型"><a href="#创建一个数据模型" class="headerlink" title="创建一个数据模型"></a>创建一个数据模型</h3><p>完成了初始项目的构建，接下来我们将创建一个自动具有REST API接口的CoffeeShop模型。</p><p>进入应用程序目录，然后运行LoopBack模型生成器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lb model</span><br></pre></td></tr></table></figure><p>生成器将提示输入数据模型的名称，输入CoffeeShop：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[?] Enter the model name: CoffeeShop</span><br></pre></td></tr></table></figure><p>它会询问您是否要将模型附加到已经一些已经定义的数据源。 此时，只有默认的内存数据源可用。按Enter键选择它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">[?] Select the data-source to attach CoffeeShop to: (Use arrow keys)</span><br><span class="line">❯ db (memory)</span><br></pre></td></tr></table></figure><p>然后，生成器将提示您使用基类作为模型。由于您在最终会把该模型连接到数据库中的持久数据源，所以这里选择PersistedModel：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[?] Select model&apos;s base class: (Use arrow keys)</span><br><span class="line">  Model</span><br><span class="line">❯ PersistedModel</span><br><span class="line">  ACL</span><br><span class="line">  AccessToken</span><br><span class="line">  Application</span><br><span class="line">  Change</span><br><span class="line">  Checkpoint</span><br></pre></td></tr></table></figure><p>PersistedModel是连接到持久性数据源（如数据库）的所有模型的基础对象，也就是基类。</p><blockquote><p>关于Loopback中的模型：</p><p>模型是LoopBack的核心，表示如数据库或其他后端服务（REST，SOAP等）等后端数据源。 LoopBack模型是具有Node和REST API的JavaScript对象。</p><p>LoopBack的一个关键功能是当您定义一个模型时，它将自动附带预定义的REST API，并具有完整的创建，读取，更新和删除操作。</p><p>Basic模型对象具有添加钩子和验证数据的方法。其他模型对象都“继承”它。模型具有继承层次结构，如下图所示：将模型附加到持久性数据源时，它将成为具有创建，检索，更新和删除操作的连接模型。 LoopBack的内置模型继承自它。</p><p><img src="http://upload-images.jianshu.io/upload_images/3396508-f7230f84f992a43d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="model的继承关系"></p></blockquote><p>LoopBack的强大优点之一是它自动为您的模型生成REST API。生成器将询问您是否要公开此REST API。 </p><p>再次输入Enter接受默认值，并通过REST暴露CoffeeShop模型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[?] Expose CoffeeShop via the REST API? (Y/n) Y</span><br></pre></td></tr></table></figure><p>LoopBack使用模型名称的复数自动创建与模型关联的REST路由。默认情况下，它将您的名称复数（通过添加“s”），但是如果需要，您可以指定自定义复数形式。</p><p>按Enter接受默认复数形式（CoffeeShops）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[?] Custom plural form (used to build REST URL):</span><br></pre></td></tr></table></figure><p>接下来，系统会询问您是要仅在服务器上创建模型，还是在<code>/common</code>目录中创建模型，这些模型可能由服务器端口和客户端LoopBack API使用。选择common，即使在这个应用程序中，你只使用服务器端模型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">? Common model or server only?</span><br><span class="line">❯ common</span><br><span class="line">  server</span><br></pre></td></tr></table></figure><p>每个模型都有属性。现在，您将为CoffeeShop模型定义一个属性“name”。</p><p>选择字符串作为属性类型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Let&apos;s add some CoffeeShop properties now.</span><br><span class="line">Enter an empty property name when done.</span><br><span class="line">[?] Property name: name</span><br><span class="line">   invoke   loopback:property</span><br><span class="line">[?] Property type: (Use arrow keys)</span><br><span class="line">❯ string</span><br><span class="line">  number</span><br><span class="line">  boolean</span><br><span class="line">  object</span><br><span class="line">  array</span><br><span class="line">  date</span><br><span class="line">  buffer</span><br><span class="line">  geopoint</span><br><span class="line">  (other)</span><br></pre></td></tr></table></figure><p>每个属性可以是可选的或必需的。输入 <code>y</code> 以将 <code>name</code> 设为必需：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[?] Required? (y/N)</span><br></pre></td></tr></table></figure><p>然后系统会提示您输入属性的默认值;按Enter键不设默认值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">? Default value[leave blank for none]:</span><br></pre></td></tr></table></figure><p>然后，系统会提示您添加其他属性。按照提示添加名为“city”的必需属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Let&apos;s add another CoffeeShop property.</span><br><span class="line">? Property name: city</span><br><span class="line">? Property type: string</span><br><span class="line">? Required? Yes</span><br><span class="line">? Default value[leave blank for none]:</span><br></pre></td></tr></table></figure><p>当提示输入下一个属性的名称时，按Enter键结束模型创建过程。</p><p>模型生成器将在应用程序的 <code>common / models</code> 目录中创建两个定义模型的文件： <code>coffee-shop.json</code> 和 <code>coffee-shop.js</code>。</p><blockquote><p>LoopBack模型生成器自动将驼峰式的模型名称（例如MyModel）转换为小写字母名称（my-model）。例如，如果您使用模型生成器创建一个名为“FooBar”的模型，它将在 <code>common/models</code> 中创建<code>foo-bar.json</code>和<code>foo-bar.js</code>文件。但是，模型名称（“FooBar”）将通过模型的名称属性进行保留。</p></blockquote><h3 id="运行应用程序"><a href="#运行应用程序" class="headerlink" title="运行应用程序"></a>运行应用程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ node .</span><br><span class="line">...</span><br><span class="line">Browse your REST API at http://0.0.0.0:3000/explorer</span><br><span class="line">Web server listening at: http://0.0.0.0:3000/</span><br></pre></td></tr></table></figure><p>现在打开你的浏览器到<a href="http://0.0.0.0:3000/explorer" target="_blank" rel="noopener">http://0.0.0.0:3000/explorer</a> 或<a href="http://localhost:3000/explorer" target="_blank" rel="noopener">http://localhost:3000/explorer</a> 。您将看到StrongLoop API资源管理器：</p><p><img src="http://upload-images.jianshu.io/upload_images/3396508-70980b142c629bc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>通过使用LoopBack的一系列简单的步骤，您创建了一个CoffeeShop模型并为它设置了一些属性，然后通过REST进行公开。</p><h2 id="三、使用API​​资源管理器"><a href="#三、使用API​​资源管理器" class="headerlink" title="三、使用API​​资源管理器"></a>三、使用API​​资源管理器</h2><h3 id="运行API​​资源管理器"><a href="#运行API​​资源管理器" class="headerlink" title="运行API​​资源管理器"></a>运行API​​资源管理器</h3><p>运行应用: <code>node .</code></p><p>转到 <a href="http://localhost:3000/explorer" target="_blank" rel="noopener">http://localhost:3000/explorer</a>。您将看到StrongLoop API资源管理器中显示了该应用程序的两个模型：User和CoffeeShop：</p><p><img src="http://upload-images.jianshu.io/upload_images/3396508-70980b142c629bc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="探索CoffeeShop模型"><a href="#探索CoffeeShop模型" class="headerlink" title="探索CoffeeShop模型"></a>探索CoffeeShop模型</h3><p>除了CoffeeShop模型之外，Loopback还会为每个应用程序生成默认的用户模型及其接口。</p><p>展开CoffeeShops之后，可以看到它所有的API接口。</p><p><img src="http://upload-images.jianshu.io/upload_images/3396508-68483e8526641f7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>大致浏览这些API接口：您可以看到它们涵盖了所有的创建，读取，更新和删除（CRUD）等操作。你可以去post一条数据来试试看。</p><h2 id="四、将API连接到数据源"><a href="#四、将API连接到数据源" class="headerlink" title="四、将API连接到数据源"></a>四、将API连接到数据源</h2><h3 id="添加一个数据源"><a href="#添加一个数据源" class="headerlink" title="添加一个数据源"></a>添加一个数据源</h3><p>现在，您将使用数据源生成器定义数据源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lb datasource</span><br></pre></td></tr></table></figure><p>生成器将提示您命名数据源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[?] Enter the data-source name:</span><br></pre></td></tr></table></figure><p>接下来，生成器将提示您输入数据源的类型，这里以mySql为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">? Select the connector for mysqlDs: (Use arrow keys)</span><br><span class="line">❯ In-memory db (supported by StrongLoop)</span><br><span class="line">  IBM DB2 (supported by StrongLoop)</span><br><span class="line">  IBM DashDB (supported by StrongLoop)</span><br><span class="line">  IBM MQ Light (supported by StrongLoop)</span><br><span class="line">  IBM Cloudant DB (supported by StrongLoop)</span><br><span class="line">  IBM DB2 for z/OS (supported by StrongLoop)</span><br><span class="line">  MongoDB (supported by StrongLoop)</span><br><span class="line">(Move up and down to reveal more choices)</span><br></pre></td></tr></table></figure><p>然后该工具将提示您输入数据源配置，对于MySQL，您可以以URL格式或单独输入所有设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connector-specific configuration:</span><br><span class="line">? Connection String url to override other settings (eg: mysql://user:pass@host/db):</span><br></pre></td></tr></table></figure><p>按回车键跳过。</p><blockquote><p>提示：尽量使用自己的MySQL数据库服务器，并创建一个名为“getting_started”的新数据库，数据库名称可以自己定义，但是请确保datasources.json中的mysqlDs.database属性与之匹配。</p></blockquote><blockquote><p>如果没有，您可以使用在demo.strongloop.com上运行的StrongLoop MySQL服务器。但它是一个共享资源，两个用户可能会同时运行创建样本数据的脚本，这可能会引发冲突。因此，我们建议您使用自己的MySQL服务器。</p></blockquote><p>如果使用StrongLoop MySQL服务器，请输入如下所示的设置。如果使用您自己的MySQL服务器，请输入服务器的主机名，端口号和登录信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">? host: demo.strongloop.com</span><br><span class="line">? port: 3306</span><br><span class="line">? user: demo</span><br><span class="line">? password: L00pBack</span><br><span class="line">? database: getting_started</span><br><span class="line">? Install loopback-connector-mysql@^2.2 Yes</span><br></pre></td></tr></table></figure><p>当工具提示您安装连接器时，运行<code>npm install loopback-connector-mysql --save</code>。该工具还将数据源定义添加到<code>server/datasources.json</code>文件中，如下所示。请注意刚刚添加的“mysqlDs”数据源，以及名为“db”的内存数据源，默认情况下是这样。</p><p><strong>/server/datasources.json</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"db"</span>: &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"db"</span>,</span><br><span class="line">    <span class="attr">"connector"</span>: <span class="string">"memory"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"mysqlDs"</span>: &#123;</span><br><span class="line">      <span class="attr">"host"</span>: <span class="string">"demo.strongloop.com"</span>,</span><br><span class="line">      <span class="attr">"port"</span>: <span class="number">3306</span>,</span><br><span class="line">      <span class="attr">"url"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="attr">"database"</span>: <span class="string">"getting_started"</span>,</span><br><span class="line">      <span class="attr">"password"</span>: <span class="string">"L00pBack"</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"mysqlDs"</span>,</span><br><span class="line">      <span class="attr">"user"</span>: <span class="string">"demo"</span>,</span><br><span class="line">      <span class="attr">"connector"</span>: <span class="string">"mysql"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将CoffeeShop模型连接到MySQL"><a href="#将CoffeeShop模型连接到MySQL" class="headerlink" title="将CoffeeShop模型连接到MySQL"></a>将CoffeeShop模型连接到MySQL</h3><p>现在你创建了一个MySQL数据源，并且有一个CoffeeShop模型，接下来需要把它们联系起来。LoopBack应用程序使用model-config.json文件将模型链接到数据源。编辑<code>/server/model-config.json</code>并查找CoffeeShop条目： </p><p><strong>/server/model-config.json</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  &quot;CoffeeShop&quot;: &#123;</span><br><span class="line">    &quot;dataSource&quot;: &quot;db&quot;,</span><br><span class="line">    &quot;public&quot;: true</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>把dataSource属性从db更改为mysqlDs。使CoffeeShop模型附加到刚刚创建和配置的MySQL数据源：</p><p><strong>/server/model-config.json</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  &quot;CoffeeShop&quot;: &#123;</span><br><span class="line">    &quot;dataSource&quot;: &quot;mysqlDs&quot;,</span><br><span class="line">    &quot;public&quot;: true</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h3 id="添加一些测试数据"><a href="#添加一些测试数据" class="headerlink" title="添加一些测试数据"></a>添加一些测试数据</h3><p>现在LoopBack中已经有了一个CoffeeShop模型，如何在MySQL数据库中创建相应的表？</p><p>您可以直接尝试执行一些SQL语句，不过LoopBack提供了一个Node API，可以自动执行一个称作auto-migration的程序。</p><p><code>loopback-getting-started</code>模块包含用于演示自动迁移的create-sample-models.js脚本。</p><blockquote><p>注意：以下自动迁移脚本是在应用程序初始启动时LoopBack执行的引导脚本的示例。使用引导脚本进行初始化，并执行应用程序启动时执行的任何其他逻辑。</p></blockquote><p><strong>/server/boot/create-sample-models.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">app</span>) </span>&#123;</span><br><span class="line">  app.dataSources.mysqlDs.automigrate(<span class="string">'CoffeeShop'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line"></span><br><span class="line">    app.models.CoffeeShop.create([&#123;</span><br><span class="line">      name: <span class="string">'Bel Cafe'</span>,</span><br><span class="line">      city: <span class="string">'Vancouver'</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      name: <span class="string">'Three Bees Coffee House'</span>,</span><br><span class="line">      city: <span class="string">'San Mateo'</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      name: <span class="string">'Caffe Artigiano'</span>,</span><br><span class="line">      city: <span class="string">'Vancouver'</span></span><br><span class="line">    &#125;, ], <span class="function"><span class="keyword">function</span>(<span class="params">err, coffeeShops</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Models created: \n'</span>, coffeeShops);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这将保存一些测试数据到数据源。</p><h2 id="五、扩展API"><a href="#五、扩展API" class="headerlink" title="五、扩展API"></a>五、扩展API</h2><h3 id="添加远程方法"><a href="#添加远程方法" class="headerlink" title="添加远程方法"></a>添加远程方法</h3><p>按着如下步骤：</p><ol><li>查看您的应用程序的<code>/common/models</code>目录。你会注意到文件夹里有coffee-shop.js和coffee-shop.json这两个文件。</li><li><p>在编辑器中打开coffee-shop.js，默认情况下，它包含一个空的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(CoffeeShop) &#123;&#125;;</span><br></pre></td></tr></table></figure></li><li><p>将以下代码添加到此函数中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">CoffeeShop</span>) </span>&#123;</span><br><span class="line">  CoffeeShop.status = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currentDate = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">var</span> currentHour = currentDate.getHours();</span><br><span class="line">    <span class="keyword">var</span> OPEN_HOUR = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">var</span> CLOSE_HOUR = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Current hour is %d'</span>, currentHour);</span><br><span class="line">    <span class="keyword">var</span> response;</span><br><span class="line">    <span class="keyword">if</span> (currentHour &gt; OPEN_HOUR &amp;&amp; currentHour &lt; CLOSE_HOUR) &#123;</span><br><span class="line">      response = <span class="string">'We are open for business.'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      response = <span class="string">'Sorry, we are closed. Open daily from 6am to 8pm.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cb(<span class="literal">null</span>, response);</span><br><span class="line">  &#125;;</span><br><span class="line">  CoffeeShop.remoteMethod(</span><br><span class="line">    <span class="string">'status'</span>, &#123;</span><br><span class="line">      http: &#123;</span><br><span class="line">        path: <span class="string">'/status'</span>,</span><br><span class="line">        verb: <span class="string">'get'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      returns: &#123;</span><br><span class="line">        arg: <span class="string">'status'</span>,</span><br><span class="line">        type: <span class="string">'string'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>这定义了一个称为“状态”的简单远程方法，它不需要任何参数，并且根据当前时间检查时间并返回一个表示“打开营业”或“对不起我们关闭”的JSON状态消息。<br>当然，在实践中，您可以使用远程方法来做更多有趣和复杂的事情，例如在将数据保留到数据库之前操纵输入数据。您还可以更改调用远程方法的路由，并定义复杂参数并返回值。</p><h3 id="使用远程方法"><a href="#使用远程方法" class="headerlink" title="使用远程方法"></a>使用远程方法</h3><ol><li>回到应用程序根目录，运行应用程序：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node .</span><br></pre></td></tr></table></figure><ol start="2"><li>转到http：// localhost：3000 / explorer查看API资源管理器。然后点击CoffeeShops，你会看到有一个新的REST端点，GET / CoffeeShop / status调用远程方法。</li></ol><p><img src="http://upload-images.jianshu.io/upload_images/3396508-6f0ca00dc2e36023.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>点击<strong>try it out</strong>！您会看到调用远程方法的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;status&quot;: &quot;Open for business.&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过LoopBack，很轻易地添加了一个远程方法。</p><h3 id="在远程方法中执行创建，检索，更新和删除方法"><a href="#在远程方法中执行创建，检索，更新和删除方法" class="headerlink" title="在远程方法中执行创建，检索，更新和删除方法"></a>在远程方法中执行创建，检索，更新和删除方法</h3><p>状态远程方法是微不足道的，但远程方法还可以访问任何标准模型创建，检索，更新和删除方法来执行数据处理和验证。这是一个简单的例子（这不是在loopback-getting-started库中）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(CoffeeShop) &#123;</span><br><span class="line">...</span><br><span class="line">  CoffeeShop.getName = function(shopId, cb) &#123;</span><br><span class="line">    CoffeeShop.findById( shopId, function (err, instance) &#123;</span><br><span class="line">        var response = &quot;Name of coffee shop is &quot; + instance.name;</span><br><span class="line">        cb(null, response);</span><br><span class="line">        console.log(response);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">  CoffeeShop.remoteMethod (</span><br><span class="line">        &apos;getName&apos;,</span><br><span class="line">        &#123;</span><br><span class="line">          http: &#123;path: &apos;/getname&apos;, verb: &apos;get&apos;&#125;,</span><br><span class="line">          accepts: &#123;arg: &apos;id&apos;, type: &apos;number&apos;, http: &#123; source: &apos;query&apos; &#125; &#125;,</span><br><span class="line">          returns: &#123;arg: &apos;name&apos;, type: &apos;string&apos;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后如果您访问远程方法，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://0.0.0.0:3000/api/CoffeeShops/getname?id=1</span><br></pre></td></tr></table></figure><p>将会得到响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;Name of coffee shop is Bel Cafe&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、添加一个静态页面"><a href="#六、添加一个静态页面" class="headerlink" title="六、添加一个静态页面"></a>六、添加一个静态页面</h2><h3 id="中间件简介"><a href="#中间件简介" class="headerlink" title="中间件简介"></a>中间件简介</h3><p>在继续之前，您首先需要了解Express中间件的基础知识。中间件只是一个JavaScript函数，可以访问表示HTTP请求的请求对象（req），表示HTTP响应的响应对象（res），以及Express应用程序的请求 - 响应周期中，由一个名为next的变量表示的下一个中间件。</p><p>中间件可以做什么？</p><ul><li>执行任何代码。</li><li>更改请求和响应对象。</li><li>结束请求 - 响应周期。</li><li>调用堆栈中的下一个中间件。</li></ul><p>LoopBack中间件就像Express中间件，除了LoopBack添加了相位的概念，使您能够轻松设置调用中间件的顺序。这避免了Express的一个棘手问题：确保中间件在需要的时候能够执行。</p><p>当您使用应用程序生成器创建应用程序时，它将创建一个<code>server/middleware.json</code>文件，指定中间件在哪个阶段执行。注册新的中间件与编辑此JSON文件一样简单：</p><p><strong>server/middleware.json</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;initial:before&quot;: &#123;</span><br><span class="line">    &quot;loopback#favicon&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;initial&quot;: &#123;</span><br><span class="line">    &quot;compression&quot;: &#123;&#125;,</span><br><span class="line">    &quot;cors&quot;: &#123;</span><br><span class="line">      &quot;params&quot;: &#123;</span><br><span class="line">        &quot;origin&quot;: true,</span><br><span class="line">        &quot;credentials&quot;: true,</span><br><span class="line">        &quot;maxAge&quot;: 86400</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;helmet#xssFilter&quot;: &#123;&#125;,</span><br><span class="line">    &quot;helmet#frameguard&quot;: &#123;</span><br><span class="line">      &quot;params&quot;: [</span><br><span class="line">        &quot;deny&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;helmet#hsts&quot;: &#123;</span><br><span class="line">      &quot;params&quot;: &#123;</span><br><span class="line">        &quot;maxAge&quot;: 0,</span><br><span class="line">        &quot;includeSubdomains&quot;: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;helmet#hidePoweredBy&quot;: &#123;&#125;,</span><br><span class="line">    &quot;helmet#ieNoOpen&quot;: &#123;&#125;,</span><br><span class="line">    &quot;helmet#noSniff&quot;: &#123;&#125;,</span><br><span class="line">    &quot;helmet#noCache&quot;: &#123;</span><br><span class="line">      &quot;enabled&quot;: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;session&quot;: &#123;&#125;,</span><br><span class="line">  &quot;auth&quot;: &#123;&#125;,</span><br><span class="line">  &quot;parse&quot;: &#123;&#125;,</span><br><span class="line">  &quot;routes&quot;: &#123;</span><br><span class="line">    &quot;loopback#rest&quot;: &#123;</span><br><span class="line">      &quot;paths&quot;: [</span><br><span class="line">        &quot;$&#123;restApiRoot&#125;&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;files&quot;: &#123;&#125;,</span><br><span class="line">  &quot;final&quot;: &#123;</span><br><span class="line">    &quot;loopback#urlNotFound&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;final:after&quot;: &#123;</span><br><span class="line">    &quot;strong-error-handler&quot;: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>middleware.json</code>中的每个顶层键都定义了一个中间件阶段：<code>initial</code>，<code>session</code>，<code>auth</code>等等，到<code>final</code>为止。在给定阶段之前和之后，还有修改器注册中间件。在给定阶段的前后也有注册中间件的修改器。</p><h3 id="更换或修改默认的根路由处理程序"><a href="#更换或修改默认的根路由处理程序" class="headerlink" title="更换或修改默认的根路由处理程序"></a>更换或修改默认的根路由处理程序</h3><p>应用程序通常需要提供静态内容，如HTML和CSS文件，客户端JavaScript文件，图像等。<br>使用LoopBack应用程序默认的脚手架很容易做到。您将去配置应用程序去启动/client文件夹中的静态资源。</p><p>首先，您必须禁用根URL的默认路由处理程序。当你加载应用程序的根URL <a href="http:// localhost:3000/" target="_blank" rel="noopener">http:// localhost:3000/</a>时，你看到应用程序用一个简单的状态消息，如这个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;started&quot;:&quot;2014-11-20T21:59:47.155Z&quot;,&quot;uptime&quot;:42.054&#125;</span><br></pre></td></tr></table></figure><p>这是因为默认情况下，脚手架应用程序具有一个名为root.js的启动脚本，该脚本为根路径（“/”）设置路由处理中间件：</p><p><strong>server/boot/root.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(server) &#123; // Install a `/` route that returns server status</span><br><span class="line">  var router = server.loopback.Router();</span><br><span class="line">  router.get(&apos;/&apos;, server.loopback.status());</span><br><span class="line">  server.use(router);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该代码说，对于根URI（“/”）的任何GET请求，应用程序将返回loopback.status（）的结果。要加入您自己的静态页面，您需要禁用此脚本。要么删除它，要么将其重命名为没有.js结尾的东西（确保应用程序不会执行它）。</p><h3 id="定义静态中间件"><a href="#定义静态中间件" class="headerlink" title="定义静态中间件"></a>定义静态中间件</h3><p>接下来，您需要定义静态中间件来为/ client目录中的文件提供服务。</p><p><strong>server/middleware.json</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&quot;files&quot;: &#123;&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>添加以下内容：</p><p><strong>server/middleware.json</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&quot;files&quot;: &#123;</span><br><span class="line">  &quot;loopback#static&quot;: &#123;</span><br><span class="line">    &quot;params&quot;: &quot;$!../client&quot; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="添加一个HTML文件"><a href="#添加一个HTML文件" class="headerlink" title="添加一个HTML文件"></a>添加一个HTML文件</h3><p>这些行定义静态中间件，使应用程序将/ client目录中的文件作为静态内容。<code>$！</code>字符表示路径是相对于middleware.json文件的位置。</p><p><strong>/client/index.html</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;&lt;title&gt;LoopBack&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;LoopBack Rocks!&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;Hello World... &lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>现在再次运行应用程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node .</span><br></pre></td></tr></table></figure><p>打开<a href="http://0.0.0.0:3000/" target="_blank" rel="noopener">http://0.0.0.0:3000/</a>：</p><p><img src="http://upload-images.jianshu.io/upload_images/3396508-b394064999a52916.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="七、添加自定义的Express路由"><a href="#七、添加自定义的Express路由" class="headerlink" title="七、添加自定义的Express路由"></a>七、添加自定义的Express路由</h2><h3 id="引入引导脚本"><a href="#引入引导脚本" class="headerlink" title="引入引导脚本"></a>引入引导脚本</h3><p>当LoopBack应用程序启动（也称为引导（bootstraps））时，它将运行<code>/server/boot</code>目录中的脚本，称为引导脚本。默认情况下，LoopBack按字母顺序加载引导脚本。</p><p>应用程序生成器创建的标准LoopBack应用脚手架中包含执行基本初始化的以下标准引导脚本（在/ server / boot中）：</p><ul><li><code>authentication.js</code> -  通过调用app.enableAuth()来启用应用程序的身份验证。</li><li><code>root.js</code> - 使用loopback.status()中间件定义<code>/</code>返回服务器状态的根路由。</li></ul><h3 id="添加一个新的启动脚本"><a href="#添加一个新的启动脚本" class="headerlink" title="添加一个新的启动脚本"></a>添加一个新的启动脚本</h3><p>例如，在<code>/server/boot</code>目录中添加一个名为routes.js的新引导脚本，其代码如下：</p><p><strong>/server/boot/routes.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(app) &#123;</span><br><span class="line">  // Install a &quot;/ping&quot; route that returns &quot;pong&quot;</span><br><span class="line">  app.get(&apos;/ping&apos;, function(req, res) &#123;</span><br><span class="line">    res.send(&apos;pong&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，也可以使用Express路由器中间件，如下所示：</p><p><strong>/server/boot/routes.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function(app) &#123;</span><br><span class="line">  var router = app.loopback.Router();</span><br><span class="line">  router.get(&apos;/ping&apos;, function(req, res) &#123;</span><br><span class="line">    res.send(&apos;pongaroo&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line">  app.use(router);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，您也可以使用Express API在server.js中添加路由。例如，在调用app.start()之前将此调用添加到app.use()：</p><p><strong>server/server.js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">app.use(&apos;/express-status&apos;, function(req, res, next) &#123;</span><br><span class="line">  res.json(&#123; running: true &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// start the server if `$ node server.js`</span><br><span class="line">if (require.main === module) &#123;</span><br><span class="line">  app.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LoopBack应用程序可以轻松地执行Express应用程序可以执行的所有操作。如果您熟悉Express，LoopBack将会更容易学习。</p><h3 id="运行引导脚本"><a href="#运行引导脚本" class="headerlink" title="运行引导脚本"></a>运行引导脚本</h3><p>现在，再次运行应用程序：</p><p>加载<a href="http://0.0.0.0:3000/ping" target="_blank" rel="noopener">http://0.0.0.0:3000/ping</a>。您会得到一个’pong’的响应。</p><p>现在一个简单的loopback应用程序就已经搭建完成了。</p><h2 id="八、下一步"><a href="#八、下一步" class="headerlink" title="八、下一步"></a>八、下一步</h2><p>接下来的教程将涵盖：</p><ul><li>在单个应用程序中使用多个数据源。</li><li>模型之间的关系。</li><li>远程钩子。</li><li>使用权限控制来保护REST接口。</li><li>用户注册和认证</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、安装&quot;&gt;&lt;a href=&quot;#一、安装&quot; class=&quot;headerlink&quot; title=&quot;一、安装&quot;&gt;&lt;/a&gt;一、安装&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;安装LoopBack工具来创建和开发LoopBack 3.0应用程序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;安装Node-js&quot;&gt;&lt;a href=&quot;#安装Node-js&quot; class=&quot;headerlink&quot; title=&quot;安装Node.js&quot;&gt;&lt;/a&gt;安装Node.js&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://nodejs.org/en/download/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;node下载地址&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;安装loopback工具&quot;&gt;&lt;a href=&quot;#安装loopback工具&quot; class=&quot;headerlink&quot; title=&quot;安装loopback工具&quot;&gt;&lt;/a&gt;安装loopback工具&lt;/h3&gt;&lt;p&gt;虽然你可以自己从头开始编写一个LoopBack应用程序，但是安装一个LoopBack CLI工具能够使它更容易入门。它将构建应用程序的基本结构，然后您可以根据需要进行自定义。&lt;/p&gt;
&lt;p&gt;LoopBack提供了两个工具的选项：&lt;a href=&quot;http://loopback.io/doc/en/lb3/Installation.html#install-loopback-cli-tool&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LoopBack CLI&lt;/a&gt; 和 &lt;a href=&quot;http://loopback.io/doc/en/lb3/Installation.html#install-ibm-api-connect-developer-toolkit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IBM API Connect开发工具包&lt;/a&gt;，这里可以选择LoopBack CLI来进行应用程序的构建。&lt;/p&gt;
    
    </summary>
    
      <category term="Web开发" scheme="http://zyqvizzz.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Node.JS" scheme="http://zyqvizzz.github.io/tags/Node-JS/"/>
    
      <category term="LoopBack" scheme="http://zyqvizzz.github.io/tags/LoopBack/"/>
    
  </entry>
  
  <entry>
    <title>空相城设定集 —— 空相城</title>
    <link href="http://zyqvizzz.github.io/%E7%A9%BA%E7%9B%B8%E5%9F%8E/"/>
    <id>http://zyqvizzz.github.io/空相城/</id>
    <published>2017-06-18T06:18:09.000Z</published>
    <updated>2018-08-27T08:13:54.298Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、时间线"><a href="#一、时间线" class="headerlink" title="一、时间线"></a>一、时间线</h2><p><strong>公元265年。</strong> 司马炎建立西晋，时任朝廷祝师的吴叶朴对黑暗的权利更迭感到绝望，于是化名梶生，隐居归田，潜心研究术法。在这段时间里，他创造出了 <strong>空相城</strong> 的雏形—— <strong>归墟谷</strong>。此时的归墟谷只能被梶生自己当作一个清修之所。</p><p><strong>公元288年。</strong> 梶生在十年的修行悟道中使归墟谷的产生了质变，他根据洛阳城的地势和结构，创造出了和洛阳城同等比例的幻想城，他将这座虚幻的城市取名为空相城。随后，他筛选了一百名洛阳城的名士文人，作为第一批开拓者进入空相城。同年，梶生卒。</p><p><strong>公元291年。</strong> 在真实的世界里，贾皇后于该年发动政变，屠杀杨太后及一众族人党羽。独揽大权之后，遂开始实施恐怖统治。此时，梶生在空相城的继任者是来自淮南巫师家族的 <strong>凤昆吾</strong>，为了维持空相城的正常运作，他需要让更多人进入这座城市。</p><p>而在洛阳城里，越来越多的百姓已经无法承受朝政黑暗和苛捐杂税，怨声载道的民间社会为凤昆吾吸纳居民的计划提供了空间。空相城开始在真实世界里露出冰山一角。</p><p><strong>公元291年到公元294年。</strong> 空相城在大规模开放的过程中人口大增，早期的规则和设定变得捉襟见肘，难以为继，凤昆吾在几经调整之后仍然无法解决问题。所以他请来了自己的同族，<strong>凤华裳</strong> 和 <strong>凤华姒(宫明月)</strong>，协助他共同修订新的运作法则。</p><p><strong>公元295年。</strong> 凤昆吾在和凤氏姐妹的合作中逐渐失去了主导地位，这也让他在空相城里失去了话语权，无奈中，他只能选择退出空相城，第三代继承者由妹妹凤华姒接任。</p><a id="more"></a><h2 id="二、捻物术"><a href="#二、捻物术" class="headerlink" title="二、捻物术"></a>二、捻物术</h2><p>梶生擅长一种名为“捻物”的巫术，本质上是一种复制术。他可以复制出城市，人，甚至风火雷电等自然现象。在捻物术的初级阶段，他将鬼谷复刻为归墟谷，并成功将自己复制到归墟谷中。</p><p>捻物术的口诀和心法出自鬼谷子的两本著作，《阴符七经》和《掐指易数》，鬼谷子所推崇的精神和冥想力的修行是实施术法的关键。由此可见，梶生是鬼谷门徒之一。</p><p><strong>tip</strong>：鬼谷两代师承关系</p><p><img src="https://upload-images.jianshu.io/upload_images/3396508-683e004244f4f034.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>他的终极目标利用术法建立一个自由有序的理想国。</p><h2 id="三、空相城的自进化运行原理"><a href="#三、空相城的自进化运行原理" class="headerlink" title="三、空相城的自进化运行原理"></a>三、空相城的自进化运行原理</h2><h3 id="阶段一："><a href="#阶段一：" class="headerlink" title="阶段一："></a>阶段一：</h3><p>梶生主导的空相城早期主要有几个概念。</p><p><strong>黄白丹</strong>：价值单位。空相城里的一切都可以通过黄白散来置换，而黄白丹本质上就是一种丹药，人们可以通过特定的炼丹术来获取它。在早期的空相城里，粮食和禽鸟都是无限的，人们并不需要通过从事任何农桑行为来维持生命，唯一需要完成的工作是炼丹，提取黄白丹，并将其充当置物的货币。</p><p><strong>冲虚魄</strong>：空相城由无数个冲虚魄维持运作，每提取出一粒黄白丹，空相城里就会诞生出一枚冲虚魄，如果把空相城比作一艘大船，冲虚魄就是载舟的水，如果有一天冲虚魄停止了供应，那这艘船也就无法继续航行。</p><p>黄白丹和冲虚魄其实是同一件事，只不过黄白丹是具象的，而冲虚魄是抽象的。提取黄白丹的过程是一种消耗行为，这和个体的精气息息相关，由于空相城的规模越来越大，梶生无法用自己有限的精气提取出足够维持空相城的黄白丹，所以才需要不断有新人进入空相城，为它提供精气。这个行为是无害的，因为人的精气本就有消有长。</p><p><strong>玄关窍</strong>：玄关窍是人体内连通表里世界的一道关卡，打开玄关窍的人将意识到自己存在于两个世界。为了避免由此可能会产生的不可控因素，所以梶生对空相城做了一个不可变更的设定：关闭玄关窍。真实和幻想就像是两条平行线，永远不能交会。</p><p>在早期的空相城里，玄关窍机制是有特例的。第一批空相民里除了梶生还有两个例外，凤昆吾和陆行简。陆行简和梶生同出一门，早在鬼谷修道期间，陆行简就已经自行冲破了玄关窍；而凤昆吾的玄关窍是梶生主动帮他打开的，因为他需要凤昆吾替他完成生前未了的工作。</p><p><strong>归元祭祀</strong>：每月一次的整理机制，目的是【对齐】、【决策】和【防止作恶】。由于空相城并不以梶生个人的意志为转移，它是一座没有统治者的自运行城市，所以先天就带有许多不稳定的潜在基因。归元祭祀实际上就是为了减小这种不稳定因素带来的影响。</p><p>对齐，是一种时间对齐机制。空相城的标准时间和真实世界同步，但是黄白丹和冲虚魄的产出速率有可能会改变个体所能感知到的时间行进快慢。黄白丹的产出效率高，时间就会变慢，而如果产出效率低，时间就会加快。每月初七是归元祭祀的日子，在祭祀之后，所有人的时间将回到同一基准线。</p><p>决策和防止作恶机制，其实就是一个数学问题（拜占庭将军问题）的社会实现。在一套自治的体系中，通过解决拜占庭将军问题来达成共识，是在没有统治者的条件下，让社会能够做出正确决定的重要办法。</p><blockquote><p>拜占庭将军问题：9个将军带领9支军队，打一场攻城战役。假设每个将军都能独立根据眼前战况做出两种判断：进攻或撤退，要求（或者最终目的是）如何让这9个将军的命令是一致的（一致性即共识）？要么一起进攻，要么一起撤退（每个将军之间也是互不信任的，也有消灭对方的动机）。</p></blockquote><p>拜占庭将军问题有两个前提，互不信任和相互对立。</p><p>所以在此情况下达成共识是一个非常复杂的过程，这里只能做一个简单的说明。空相城归根结底是一个社会集群，所以必然有发布决策的需求，这个决策将从多个方面产生，如：明悬寺、司星署或者个体百姓等等，决策最终被提交到小戴府，由小戴府成员整理并带到祭祀上。但实际上，决策每时每刻都在发生，一次祭祀无法处理所有的决策，所以归元祭祀只负责解决一些涉及到绝大部分百姓或者影响空相城进程的决策。</p><p>而其他细微的决策，通常交给明悬寺来处理，明悬寺并不是机构，而是一种人形化的机制，或者说是规则的一部分。如果有人试图在城中作恶。明悬寺会随机组织一部分百姓来为其裁决。这又涉及到了另一个问题，案件的调查，明悬寺启动调查同样需要组织一部分百姓来进行投票决议，如果半数以上同意，明悬寺将有权开启调查小戴府档案的权限，小戴府和明悬寺一样，是机制而非机构，它将记录所有在空相城中发生的事件，当然，梶生为它设计了一个私密保护机制。明悬寺调取小戴府的记录之后，再随机组织百姓进行共同决议。</p><p>人们并不需要知道拜占庭将军问题的实际解法，梶生在建立规则的初期已经对此做出了内部的封装，百姓只需要做一件事，做出决策。每个人的决策都可以追溯，因为每个决策和人们体内的玄关窍是关联起来的。</p><p>在月度的祭祀典礼上，人们需要完成三件事。此处梶生主要参考了《灵棋经》中的仪式。</p><ol><li>请神</li><li>祝祷</li><li>奏乐</li><li>归位</li><li>送神</li></ol><p><strong>穷蝉神</strong>：穷蝉神没有实质性的功能，它的存在是为了让人们相信神迹。梶生不必向人们解释空相城复杂的运作方式，他要创造一个全知全能的神，有了神，空相城就有了合理性。</p><p><strong>小戴府</strong>：记录黄白丹和冲虚魄的流动和消耗，梶生认为，人世的一切黑暗来自于权和钱。取缔了权，公开化钱的去向，大力推崇礼法，就能建立一个完美的社会体系。小戴府是对所有人公开的。梶生对除明悬寺外的人进入小戴府的次数进行了限制，每月最多五次。</p><p>小戴府中有两种角色，看守者和记录者。看守者是梶生创造出的复制人，他们完全按照规则行动，而记录者则是由志愿加入小戴府的百姓组成。故事的线索人物苏住就是其中之一。</p><p><strong>明悬寺</strong>：明悬寺和小戴府一样，它存在的目的同样是为了约束百姓不去作恶。但小戴府是客观约束，而明悬寺则是一种主动的约束。所以明悬寺的设计要比小戴府复杂得多。也正是因为这一点，梶生直到去世，都没能设计出一个完美的明悬寺。明悬寺里有一个重要角色，叫做 <strong>假面司直</strong>，他们是一批由梶生用捻物术创造出的，必须按照特定准则行事的复制人。在他设计好准则之前，第一代假面司直由他的同门师侄陆科代理，而他捻人的模板，也正是陆科和他自己的融合体。</p><p>创造假面司直的难度在于，他们需要拥有更高级的分辨力和行动力，他们的任务包括调查案件，组织民间会议，当有人试图破坏空相城时，他们要去组织破坏行为的发生。也就是说，在百分百执行规则的同时，他们应该是有血有肉，并且善于学习和思考的。</p><p><img src="https://upload-images.jianshu.io/upload_images/3396508-8b774b1b42ba12f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="空相城结构"></p><h3 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h3><p>空相城还有一个先天特性：不可逆，不可篡改。凤昆吾在人口基数变大的情况下，面临最大的考验是他无法保证归元祭祀的可靠决策、效率以及对齐机制的一致性。</p><p>这里涉及到了另一个经济学问题，不可能三角。一致性、效率和可靠性形成了一个三角，他只能在这个三角里做出三选二的选择，一定有一个要被舍弃。</p><p>第一代的梶生解决了共识问题，第二代的凤昆吾则需要解决不可能三角问题。</p><p>所以他在长期的考量之后，决定在归元祭祀上提出自己的提议，改变共识。这个提议在当时负载过重的空相城里得到了大部分人的支持。但在规则上，旧的规则是无法被修改的，所以，凤昆吾在承认除归元祭祀以外的旧规则的前提下，开启了 <strong>历山门</strong>，相当于走上了一条分叉路。</p><p>归元祭祀被实质上取缔，从月度祭祀转变为了年度祭祀。取代它的是一项新的机制：<strong>虚灵集议</strong>和<strong>玄书契约</strong>。</p><p><strong>历山门</strong>：这是凤昆吾创造的一种迁移法术，在空相城的基础上再复制出一个拥有新规则的空相城。原有的空相城依然存在，他把这个秘密保留了下来。之所以保留秘密，是因为他和梶生之间的微妙关系，凤昆吾和梶生都是当世高人，且都有做哲人王的野心，而有句话叫做王不见王，梶生在空相城初期的规则制定里占据了绝对的主导地位，这使得凤昆吾的许多想法无法付诸现实。所以在梶生把空相城交给他之后，他希望自己可以创造出一个更加完美的社会体系。</p><p><strong>虚灵集议</strong>：类似于元老院机制，最早进入空相城的人大都是经过梶生和凤昆吾精心挑选出来的有识之士，与此同时，他们积累了相对更多的黄白丹，也为空相城创造出了更多的冲虚魄。所以他决定在拥有最多黄白丹的一百人里随机抽取二十三人，由他们来为空相城做决策，每次决策都将重新随机抽取决策人，尽可能保证公平。</p><p><strong>玄书契约</strong>。一百名候选人并不是绝对不变的，后期进入空相城的人也可以通过创造贡献，从而得到进入虚灵集议名单的机会。另外，一百人不是上限。贡献度可以被精准度量的原因在于凤昆吾拓展了黄白丹和冲虚魄的概念，产生冲虚魄的先决条件不再只限于提取黄白丹这一件事，创造艺术品，种植作物等行为都可以产生一定量的冲虚魄。</p><h3 id="阶段三："><a href="#阶段三：" class="headerlink" title="阶段三："></a>阶段三：</h3><p>虚灵集议制度不可避免的走向了门阀制度，凤昆吾也在长期的斗争中逐渐失去了对空相城的控制，如果他想重掌权力，他需要再次开启历山门，但是开启历山门需要通过虚灵集议，而虚灵集议此时已经完全被凤氏姐妹控制。</p><p>虚灵集议制度导致了势力的诞生，势力越大的人可以针对性的做出更高的贡献，同时，势力大的人一旦拉拢了名单里的半数以上参选者，虚灵集议制度就将变成寡头制度。凤昆吾正是因为无法解决这个问题，从而被凤氏姐妹排挤出了空相城。凤氏姐妹接管空相城之后，她们面临的问题是无法像梶生和凤昆吾一样，拥有真正改造空相城的能力，她们需要找到新的鬼谷门徒，在此之前，她们还要编造一些谎言。凤氏姐妹在虚灵集议制度中成为最大的一股势力之后，把制度转为极权制度。螟蛉祭祀制度在后面单独介绍。</p><p>她们虚构出一个对空相城虎视眈眈的强大敌人，并声称城内潜伏着通敌者。她们所代表的权利阶级自导自演了一出穷蝉神被敌对势力谋杀的戏码，</p><p><strong>善恶罐</strong>：虚构出一个对空相城虎视眈眈的强大敌人，并声称城内潜伏着通敌者。她们开发了一个能够收集冲虚魄的工具，名为善恶罐，</p><p>第三个谎言：资源紧缺，环境恶化。</p><p><strong>归元祭祀</strong>：新的祭祀规则完全取缔了过去的归元祭祀。在凤昆吾的规则下，归元祭祀只是一个象征性的仪式，但是凤华姒接任后，它成了人们生活里最重要的事。</p><h3 id="阶段四"><a href="#阶段四" class="headerlink" title="阶段四"></a>阶段四</h3><p>方春木和陆科的正面对决。</p><p>方春木正式加入凤氏姐妹阵营，而陆科也终于在成功摸索出捻物术后，开始了对空相城的反击。</p><p><strong>罔极阁</strong>：空相城发展停滞后的第一次伟大尝试，这是一条独立于空相城的侧翼。为了摆脱凤氏姐妹的控制，陆科回到历山祭祀前的空相城，并基于最初的规则，把罔极阁建造在了原始区中。问题是所有人都生活在历山祭祀之后的空相城里，罔极阁和第二代空相城并没有直接的关联，人们如果想进入罔极阁，必须要进行一系列繁琐的操作：从历山区回退到原始区，以一比十的比例兑换黄白丹，并宣誓承认原始区的规则；然后把兑换而得的黄白丹以一比一的比例锁定在原始区和罔极阁之间的桥接体中；最后正式进入罔极阁。</p><p>罔极阁的创始者有六名：陆科——规则设计者，孙俊忠——赌场经营者，柳羊公——建筑设计者，不知晓——规则维护者，卢冲、沈开河——中间人。</p><p>陆科把罔极阁设计成为一个一旦开始就永不休止的巨型赌场，又为这个赌场想了个极具挑衅意味的口号：“逃离这个骗局”。</p><p>赌局玩法：陆科在罔极阁中存放一个漏壶，以一天为单位计时，每新增一个投注者，漏壶的计时时长就会增加一刻，只要漏壶不见底，这个赌局就将一直进行，而一旦漏壶见底，也就是当没人继续投注时，这个游戏就将结束，最后一名投注者作为胜出者，他将获得天价赌金。由于最终胜者只有一人，这样一来越先进入游戏的人机会就越渺茫，为了鼓励人们进入赌局，他又设计了一个分红机制——后进入赌局的人的赌注，将抽取一部分金额作为先入局者的红利，只要这个赌局不停，先入局的人就会一直瓜分后入局的人的注金。同时，陆科还在赌场里建造了四座庄园：蛇、虫、鼠、蚁。蛇庄的人只会分蛇庄的钱，蚁庄的人只会分蚁庄的钱。分设四庄的目的有两个：让玩家之间相互博弈，满足柳羊公的艺术才能。</p><p>除了赌局，罔极阁还有另一场游戏：无限制游戏。玩家可以在罔极阁中做他想做的一切，这个游戏无法举例说明，一切全看玩家的想象力和野心，人可以死而复生。除了漏壶不会被破坏，赌局不会停息之外，你甚至可以想办法拆了四大庄园。</p><p>这个游戏的目的是挖掘人性里的所有黑暗面，而陆科的目的则是为了把空相城的黄白丹全部转移到罔极阁里。在赌局结束之前，会有一大笔黄白丹和冲虚魄聚合在罔极阁里，而陆科作为空相城的第一元老，在历山门开启之后，原始空相城后续产生的所有冲虚魄都只由他一人生产，他手里拥有一比巨大额度的黄白丹。当这个赌局大到没人能接的时候，他依然拥有足够的黄白丹来终结赌局。</p><p>他需要收集半数以上的冲虚魄，用以夺取空相城的控制权。</p><p><strong>妄人楼</strong>：陆科认为，历山区的空相城在凤氏姐妹的管制下，已经到了密不透风的程度，历山区的人无法绕开监控，所以他得另辟蹊径。他要打通空相城和洛阳城之间的关联，也就是要打通人们的玄关窍。</p><p>方春木作为他的头号对手，在捻物术上丢了先机。所以在他想到摧毁侧翼的办法前，他必须要在陆科之前赢得赌局，</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>空相城历经三个阶段：</p><ul><li>一人一票的民主制。</li><li>集中选票的议会制。</li><li>极权制。</li></ul><h2 id="四、顶层机构的变迁"><a href="#四、顶层机构的变迁" class="headerlink" title="四、顶层机构的变迁"></a>四、顶层机构的变迁</h2><h3 id="第一代"><a href="#第一代" class="headerlink" title="第一代"></a>第一代</h3><ul><li>祝使：梶生(吴叶朴)；</li><li>司星署祭司：凤昆吾；</li><li>明悬寺主理：代面使(陆行简)；</li><li>小戴阁阁主：梶生</li></ul><h3 id="第二代"><a href="#第二代" class="headerlink" title="第二代"></a>第二代</h3><ul><li>祝使：凤昆吾；</li><li>司星署祭司：麻衣道长；</li><li>明悬寺主理：代面使(疯剑客)；</li><li>小戴阁阁主：苏住</li></ul><h3 id="第三代"><a href="#第三代" class="headerlink" title="第三代"></a>第三代</h3><ul><li>祝使：苏住</li><li>司星署祭司：凤华姒(宫明月)</li><li>明悬寺主理：代面使(疯剑客)；</li><li>小戴阁阁主：梁宿直</li></ul><blockquote><p>tip：据此设定，陆科是在最早期就是空相城的顶层人物，陆科生于公元273年，师出鬼谷鱼丈翁门下，289年他只有16岁。所以他在出师当年就被梶生带进了空相城，并让他掌管明悬寺，这暗示梶生对于鬼谷十分了解。进一步挖掘下去，鬼谷永远只有两名对立的门徒，如苏秦张仪和庞涓孙膑；而鱼丈翁和梶生年纪相仿，所以他们应该是师兄弟的关系。这也为陆科破解空相城的秘密提供了合理的支撑点，捻物术源于鬼谷。</p></blockquote><pre><code>明悬寺：早期是一个秘密机构，职责和现实里的御史台相近。梶生建立明悬寺的目的也是出于一种公平的想法，它的最终形态是有规则无意识，类似于一种机器人的存在，他知道陆科做不到这一点，所以一直在试着复制自己和陆科，并希望把这些复制品打造成一支维护规则的监察队伍。明悬寺的后期，就是第二阶段，梶生没能创造出真正稳定版本的卫道者，他的最后一个复制品是他和陆科的结合体，疯剑客。疯剑客和陆科的权利很大，梶生几乎为他们开放了全部的壁垒。</code></pre><p><br></p><pre><code>祝使：祝使的角色在梶生之后，理论上就没有了制定新规则的权利，他唯一的权利是为空相城继续吸纳人口。但实际上，梶生和凤昆吾达成了协议，凤昆吾依然拥有一部分修改规则的权利。另外淮南凤氏精通咒禁术，凤昆吾错信了凤氏姐妹，最终导致了空相城的失控。</code></pre><p><br></p><pre><code>司星署司星署祭司是维持民众信仰的角色，在前两个阶段，这个角色只用来赋予规则合理性。到了第三代，神权占据了制高点，祭司才成为空相城的实际控制者。</code></pre><p><br></p><pre><code>小戴阁：记录机构，记录规则，选票，以及在空相城发生的一切，这也是空相城共识体系最重要的支撑点。小戴阁代表着能量的总集。</code></pre><h2 id="五、分叉区"><a href="#五、分叉区" class="headerlink" title="五、分叉区"></a>五、分叉区</h2><p>梶生的空相城在凤氏姐妹的控制下彻底瓦解。她们在空相城的原有基础上重写规则，导致空相城被分叉，分叉行动之所以能成功，最重要的原因在于她们推行的极权制度。她们强制定期收集所有人的能量，并监控了所有人的善恶罐。当她们希望分叉的时候，绝大部分的能量都集中于她们的手上，所以她们在神不知鬼不觉的情况下完成了分叉。</p><h2 id="六、侧翼区"><a href="#六、侧翼区" class="headerlink" title="六、侧翼区"></a>六、侧翼区</h2><p>梶生离世，凤昆吾退出，第一批空相城百姓被凤氏控制，陆科找到了梶生和凤昆吾留下的线索，在吴人坊里为自己打通了一条侧翼。在不承认分叉区的基础上，沿袭空相城原有的基本准则，开辟了一个凤氏姐妹无法控制的独立空间，但是它由实实在在的存在于分叉区之中。进入侧翼的过程如下：从分叉区回到空相城（原始区），再从原始区中签订协议进入侧翼。从分叉回到原始区的方式是在每次投票过程中投给原始区，从原始区进入侧翼的方式是把自己在原始区里的能量冻结，并和陆科完成赌博共识，然后侧翼将为他提供和原始区中相同的一比一的能量。</p><h2 id="七、昭告天下的空相城"><a href="#七、昭告天下的空相城" class="headerlink" title="七、昭告天下的空相城"></a>七、昭告天下的空相城</h2><p>陆科在洛阳城里和说书人联手，将空相城的存在和开辟侧翼的方式公之于众。随后，一大批组织成功进入了空相城，并创造了自己的侧翼。以石季伦为首的金谷园，海公子的平乐街，陆科的罔极阁，王孙农的明王道馆。除此之外，还有凤昆吾的方孔山庄，贺平子的捞鱼坊，苏青璃的春深居，以及骆天师的灵棋门等。他们有人选择在分叉区上创造侧翼，有人选择在原始区上创造侧翼。至此，空相城在真实的世界里成了人尽皆知的存在。</p><h2 id="八、空相城的第四阶段"><a href="#八、空相城的第四阶段" class="headerlink" title="八、空相城的第四阶段"></a>八、空相城的第四阶段</h2><p>东宫把空相城带到了第四个阶段，他们的侧翼是一条无需能量维持的联盟区。创造此链的人是方春木，也就是陆科在鬼谷中的师兄。他是太子党成员。联盟区的优势在于稳定性和时间行进速度。</p><h2 id="九、联盟区和共生区"><a href="#九、联盟区和共生区" class="headerlink" title="九、联盟区和共生区"></a>九、联盟区和共生区</h2><p>侧翼，分叉区和原始区都属于共生区，依托的是每个人(节点)为整个体系提供的能量，它有一大缺点，小戴阁需要记录大量信息，这会导致时间的行进将会越来越慢，大量的能量聚集在小戴阁里，同时错综复杂的事件也会让时间和自然规律等客观条件变得不稳定。侧翼有助于帮助原始区或分叉减轻负载，但效果有限。联盟区牺牲了分发能量的过程，把能量集中于一个或多个节点上，它将保持充足的稳定性和时间行进速度。但如果想破坏联盟，只需要控制住特定的节点即可。</p><h2 id="十、原始区和分叉区的空相城"><a href="#十、原始区和分叉区的空相城" class="headerlink" title="十、原始区和分叉区的空相城"></a>十、原始区和分叉区的空相城</h2><h3 id="原始区"><a href="#原始区" class="headerlink" title="原始区"></a>原始区</h3><p>空相城是梶生为躲避现实所做的一个实验，是他对理想世界的构想。他建立了最初的规则，不干预城市的发展，使城市进入完全自制运行的状态。</p><p>城市里没有刑罚、疾病、饥荒，没有统治阶级，礼法是城市运行的唯一准则。</p><p><strong>穷蝉神</strong></p><p>早期空相城里的最高神。人们依照礼仪供奉穷蝉神，目的是为了保持意识形态的统一。</p><p><strong>虎蛟草</strong></p><p>在指定的区域种植虎蛟草是获取能量的唯一方式。</p><p><strong>仓库</strong></p><p>早期的能量只能转化为单一的钱币，用于置换由梶生创造出的物品和食物，但是梶生的精力是有限的，他无法创造出世界上所有的东西，所以也就无法为人们提供定制化的物品。</p><p>他解决此问题的方式是开放差异协定。他广泛收集原材料图鉴，而后将大批原材料“捻”到空相城的仓库里。人们在接下来的种植活动中可以由能量换取原材料进行定制化的加工。</p><p><strong>机构</strong></p><ul><li>大学：教育部门</li><li>平乐馆：礼乐部门</li><li>明悬寺：监察部门</li><li>司星署：祭祀部门</li><li>小戴阁：内务部门，统一执行资源分配和登记等事务</li></ul><h3 id="分叉区"><a href="#分叉区" class="headerlink" title="分叉区"></a>分叉区</h3><p><strong>品级制度</strong></p><p>分一到九品，把所有人分为不同等级。</p><p>将定期触发降雨，丰收，生育等事件</p><p>空相城以中国的道家学派作为外壳，并以区块链、图灵机和高等算法等计算机概念作为内核。而背后展示的是一种社会形态的变更，封建时代的哲人王创造了跨越式的民主，民主制度又在低效率之下转向了元老掌权的代表大会制度，最终在人性的驱使下，最初的理想国分崩离析，走向极权。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、时间线&quot;&gt;&lt;a href=&quot;#一、时间线&quot; class=&quot;headerlink&quot; title=&quot;一、时间线&quot;&gt;&lt;/a&gt;一、时间线&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;公元265年。&lt;/strong&gt; 司马炎建立西晋，时任朝廷祝师的吴叶朴对黑暗的权利更迭感到绝望，于是化名梶生，隐居归田，潜心研究术法。在这段时间里，他创造出了 &lt;strong&gt;空相城&lt;/strong&gt; 的雏形—— &lt;strong&gt;归墟谷&lt;/strong&gt;。此时的归墟谷只能被梶生自己当作一个清修之所。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;公元288年。&lt;/strong&gt; 梶生在十年的修行悟道中使归墟谷的产生了质变，他根据洛阳城的地势和结构，创造出了和洛阳城同等比例的幻想城，他将这座虚幻的城市取名为空相城。随后，他筛选了一百名洛阳城的名士文人，作为第一批开拓者进入空相城。同年，梶生卒。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;公元291年。&lt;/strong&gt; 在真实的世界里，贾皇后于该年发动政变，屠杀杨太后及一众族人党羽。独揽大权之后，遂开始实施恐怖统治。此时，梶生在空相城的继任者是来自淮南巫师家族的 &lt;strong&gt;凤昆吾&lt;/strong&gt;，为了维持空相城的正常运作，他需要让更多人进入这座城市。&lt;/p&gt;
&lt;p&gt;而在洛阳城里，越来越多的百姓已经无法承受朝政黑暗和苛捐杂税，怨声载道的民间社会为凤昆吾吸纳居民的计划提供了空间。空相城开始在真实世界里露出冰山一角。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;公元291年到公元294年。&lt;/strong&gt; 空相城在大规模开放的过程中人口大增，早期的规则和设定变得捉襟见肘，难以为继，凤昆吾在几经调整之后仍然无法解决问题。所以他请来了自己的同族，&lt;strong&gt;凤华裳&lt;/strong&gt; 和 &lt;strong&gt;凤华姒(宫明月)&lt;/strong&gt;，协助他共同修订新的运作法则。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;公元295年。&lt;/strong&gt; 凤昆吾在和凤氏姐妹的合作中逐渐失去了主导地位，这也让他在空相城里失去了话语权，无奈中，他只能选择退出空相城，第三代继承者由妹妹凤华姒接任。&lt;/p&gt;
    
    </summary>
    
      <category term="小说" scheme="http://zyqvizzz.github.io/categories/%E5%B0%8F%E8%AF%B4/"/>
    
    
      <category term="假面生死簿" scheme="http://zyqvizzz.github.io/tags/%E5%81%87%E9%9D%A2%E7%94%9F%E6%AD%BB%E7%B0%BF/"/>
    
  </entry>
  
  <entry>
    <title>在Hexo NexT中集成Algolia搜索服务时遇到的坑</title>
    <link href="http://zyqvizzz.github.io/%E5%9C%A8Hexo%20NexT%E4%B8%AD%E4%BD%BF%E7%94%A8Algolia%E6%90%9C%E7%B4%A2%E6%9C%8D%E5%8A%A1%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <id>http://zyqvizzz.github.io/在Hexo NexT中使用Algolia搜索服务时遇到的坑/</id>
    <published>2017-05-16T10:31:09.000Z</published>
    <updated>2018-08-15T10:00:50.790Z</updated>
    
    <content type="html"><![CDATA[<p>首先，需要确认一下NexT的版本已经更新到了5.1.0之后。</p><p>按照NexT提供的API进行操作，在Algolia官网上注册一个账号，然后创建一个新的Index，接着安装Hexo Algolia。</p><p>到了获取key这一步，很多人就出了问题。因为在API Key的页面里有很多不同的Key，在这里一定要确认我们需要配置的API Key是<code>Search-Only API Key</code>，</p><p>配置页面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">algolia:</span><br><span class="line">  applicationID: &apos;applicationID&apos;</span><br><span class="line">  indexName: &apos;indexName&apos;</span><br><span class="line">  chunkSize: 5000</span><br></pre></td></tr></table></figure><a id="more"></a><p>这里要注意的是applicationID和indexName不能加引号。</p><p>配置完成之后，需要更新Index，在我们的网站和Algolia之间建立一个关联。</p><p>首先需要在All API key页面里先配置好你的网站。</p><p><img src="https://upload-images.jianshu.io/upload_images/3396508-81008d0c7e48b244.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="All API key"></p><p><img src="https://upload-images.jianshu.io/upload_images/3396508-170688b5354f0fe9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="需要勾选项目"></p><p>接下来在命令行里输入如下命令，<code>Search-Only API key</code>要替换为你自己的Search-Only API key。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ export(windows 为 set) HEXO_ALGOLIA_INDEXING_KEY=Search-Only API key</span><br><span class="line">$ hexo algolia</span><br></pre></td></tr></table></figure><p>所有完成了之后，按照NexT文档上的最后一步：把algolia search里的enable改为true，完成配置。</p><p>现在打开你的页面，你会发现搜索界面已经有了，但是搜索后的页面总是会跳转到一个神奇的”yoursite.com”。这里是Hexo-Algolia作者给我们留下的最大的一个坑，因为他在config.js</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先，需要确认一下NexT的版本已经更新到了5.1.0之后。&lt;/p&gt;
&lt;p&gt;按照NexT提供的API进行操作，在Algolia官网上注册一个账号，然后创建一个新的Index，接着安装Hexo Algolia。&lt;/p&gt;
&lt;p&gt;到了获取key这一步，很多人就出了问题。因为在API Key的页面里有很多不同的Key，在这里一定要确认我们需要配置的API Key是&lt;code&gt;Search-Only API Key&lt;/code&gt;，&lt;/p&gt;
&lt;p&gt;配置页面：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;algolia:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  applicationID: &amp;apos;applicationID&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  indexName: &amp;apos;indexName&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  chunkSize: 5000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Web开发" scheme="http://zyqvizzz.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Hexo" scheme="http://zyqvizzz.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>
